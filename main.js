(()=>{"use strict";var __webpack_modules__={585:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n// UNUSED EXPORTS: Game, onDeviceReady\n\n// EXTERNAL MODULE: ./node_modules/ramda/es/index.js + 234 modules\nvar es = __webpack_require__(402);\n;// CONCATENATED MODULE: ./src/common/debug.ts\n\n\n\nconst isDevelopment = \"production\" !== 'production';\nconst onlyIfDevelopment = (fn, elseFn /* Func<any, any> */) => (...args) => (isDevelopment && fn(...args)) || (elseFn && elseFn(...args));\nconst happenAfterS = (cb, seconds = 1) => {\n    setTimeout(cb, seconds * 1000);\n};\nconst debug_debugLog = onlyIfDevelopment(console.log);\nconst debug_debugWarn = onlyIfDevelopment(console.warn);\nconst debugInfo = onlyIfDevelopment(console.info);\nconst debugError = onlyIfDevelopment(console.error);\nconst debugNotImplemented = onlyIfDevelopment(console.error.bind(null, '! NOT IMPLEMENTED !'));\nconst setGlobalVar = onlyIfDevelopment((nameOrFn, val) => {\n    if (isFunction(nameOrFn)) {\n        ;\n        window[nameOrFn.name] = nameOrFn;\n    }\n    else {\n        ;\n        window[nameOrFn] = val;\n    }\n});\n/**\n * A debug function which will return the window[windowVarName] once we assign it\n * a value (and will fetch the value from the window each time). This gives us\n * the chance to supply values in the F12 dev tools via window[windowVarName]\n *\n * Note: the first assignment of the value is the original value passed\n * @param windowVarName\n * @param actualValue The value, preferably a constant, like a configuration variable.\n * This will be assigned only once (the first time) to the windowVarName (window variable)\n * @returns\n */\nconst debug_useDebugConstant = onlyIfDevelopment((windowVarName, actualValue) => {\n    const _windowDataKey = 'EXPOSED_DEBUG_VARS';\n    window[_windowDataKey] = (0,es/* defaultTo */.yAE)({}, window[_windowDataKey]);\n    const hasBeenAssignedOnce = Boolean(window[_windowDataKey][windowVarName]);\n    if (!hasBeenAssignedOnce) {\n        setGlobalVar(windowVarName, actualValue);\n        window[_windowDataKey][windowVarName] = window[_windowDataKey][windowVarName] || {\n            // first-time-assignment value\n            firstValue: actualValue,\n            resetValue: () => setGlobalVar(windowVarName, window[_windowDataKey].firstValue),\n            // TODO:FEAT - later, store to local storage for \"automatic-save\" (then load from there)?\n        };\n        window[_windowDataKey][windowVarName].firstValue = actualValue;\n    }\n    return getGlobalVar(windowVarName) || actualValue;\n}, \n// if not in dev mode, simply return the value as-is\n(_windowVarName, actualValue) => actualValue);\nconst getGlobalVar = (name) => window[name];\nconst logGlobalVar = onlyIfDevelopment((name, prefix) => console.log(prefix, getGlobalVar(name)));\nconst exposeToWindow = (varObj) => {\n    if (true)\n        return;\n    const result = Object.keys(varObj).map((key) => {\n        const value = varObj[key];\n        window[key] = value;\n        window.__EXPOSED = window.__EXPOSED || {};\n        window.__EXPOSED[key] = value;\n        return [key, value];\n    });\n    return result;\n};\nconst createFpsCounter = onlyIfDevelopment(() => {\n    if (document.getElementById('fpsCounter')) {\n        return;\n    }\n    const el = document.createElement('div');\n    el.setAttribute('id', 'fpsCounter');\n    el.style.position = 'absolute';\n    document.body.appendChild(el);\n    setInterval(() => {\n        getMonitorRefreshRate().then((fps) => {\n            // console.log('FPS', fps.toFixed(2))\n            setGlobalVar('__FPS', fps);\n            el.innerText = 'FPS:' + fps.toFixed(2);\n        });\n    }, 1000);\n});\nconst destroyFPSCounter = onlyIfDevelopment(() => {\n    document.getElementById('fpsCounter').remove();\n});\n// export const writeOutEverySAndClearConsole = (cb, ...args) => {\n//   console.clear()\n//   setInterval(() => {\n//     debugLog(cb(...args))\n//     writeOutEverySAndClearConsole(cb, ...args)\n//   }, 1000)\n// }\n\n;// CONCATENATED MODULE: ./src/common/func.ts\n\n\n\n// export const isNil = <T extends any>(v: T) => v === null && v === undefined\nconst isNotNil = (v) => v !== null && v !== undefined;\nconst identityIfNotNil = (v) => v !== null && v !== undefined && v;\nconst isBetweenInclusive = (minInclusive, maxInclusive, value) => value >= minInclusive && value <= maxInclusive;\nconst getObjPos = (0,es/* pick */.eiS)(['x', 'y']);\nconst addPoints = (p1, p2) => ({ x: p1.x + p2.x, y: p1.y + p2.y });\nconst subtractPoints = (p1, p2) => ({ x: p1.x - p2.x, y: p1.y - p2.y });\nconst dividePoint = (p1, divisor) => ({\n    x: p1.x / divisor,\n    y: p1.y / divisor,\n});\nconst func_multiplyPoint = (p1, factor) => ({\n    x: p1.x * factor,\n    y: p1.y * factor,\n});\nconst deepMerge = (v1, v2) => {\n    if (Array.isArray(v1) && Array.isArray(v2)) {\n        return (0,es/* uniq */.jj$)((0,es/* concat */.zoF)(v1, v2));\n    }\n    else if (typeof v1 === 'object' && typeof v2 === 'object' && !(0,es/* isNil */.kKJ)(v1) && !(0,es/* isNil */.kKJ)(v2)) {\n        return (0,es/* mergeWith */.bTk)(deepMerge, v1, v2);\n    }\n    else {\n        return v2;\n    }\n};\nexposeToWindow({ deepMerge, merge: es/* mergeDeepRight */.BPw });\nconst deepUpdate = (obj, value, path) => {\n    var i, pathArr = path.split('.');\n    for (i = 0; i < pathArr.length - 1; i++)\n        obj = obj[pathArr[i]];\n    obj[pathArr[i]] = value;\n};\nconst updateFlag = (path, flag, when) => (obj) => () => when ? when(obj) && deepUpdate(obj, flag, path) : deepUpdate(obj, flag, path);\nconst objForEach = (cb, obj) => toPairs(obj).forEach(([key, value], ind, collection) => {\n    cb({ key, value, ind, collection });\n});\n// export const getDataKey\nconst payloadOrEmptyObj = (0,es/* propOr */.Uth)({}, 'payload');\n// export const payload = <P>(ev: IEvent) => payloadOrEmptyObj<IEvent, P>(ev)\n// export const payloadProp = <T>(_prop: string) =>\n// compose<[IEvent], string, T>(prop(_prop) as any, payloadOrEmptyObj)\n// export const payloadPath = <T>(dottedPath: string) =>\n//   compose<IEvent, string, T>(path(dottedPath.split('.')), payloadOrEmptyObj)\n// export const payloadPropOr = <T>(prop: string, defaultVal: any) =>\n//   compose<IEvent, string, T>(propOr(defaultVal, prop), payloadOrEmptyObj)\n// export const payloadPathOr = <T>(dottedPath: string, defaultVal: any) =>\n//   compose<IEvent, string, T>(pathOr(defaultVal, dottedPath.split('.')), payloadOrEmptyObj)\n// exposeToWindow({ payloadPropOr, payloadPathOr })\nconst matchesId = (id) => propEq('id')(id);\nconst notMatchesId = (id) => complement(matchesId(id));\n/** An alternative to the switch {} statement */\nconst basedOn = (paths) => (choice) => {\n    return paths[choice]();\n};\nconst switchOn = basedOn;\nconst basedOnPartial = (paths) => (choice) => {\n    return paths[choice] ? paths[choice]() : paths['default'] && paths['default']();\n};\n/**\n * Similar to basedOn but checks if a number is between the range [n1, n2)\n * where n1...nN are the passed paths\n */\nconst basedOnRanges = (numberBoundariesToFN) => (numValue) => {\n    // TODO:FIX BUGS -> 2) floats not working\n    const rangeStarts = Object.keys(numberBoundariesToFN).map((k) => parseFloat(k));\n    const firstRangeBeginningGreaterThanValue = rangeStarts.find((rangeStartVal, ind) => {\n        const nextNum = rangeStarts[ind + 1];\n        return numValue >= rangeStartVal && (numValue < nextNum || nextNum === undefined);\n    });\n    if (firstRangeBeginningGreaterThanValue !== undefined) {\n        return numberBoundariesToFN[firstRangeBeginningGreaterThanValue]();\n    }\n    else {\n        return noop();\n    }\n};\nconst switchOnRanges = (/* unused pure expression or super */ null && (basedOnRanges));\nconst numToFixed = (n, digits) => parseFloat(n.toFixed(digits));\nconst mapObjectValuesToFnCalls = (fn, obj) => {\n    const res = mapObjIndexed((innerObj, presetName, topObject) => {\n        // create a Function that when called will invoke `fn` with the inner object, e.g.\n        //#region EXPLAIN\n        /* this\n          ...\n          smoothy: {\n            distortFactor1: 1,\n            distortFactor2: 0.2,\n          },\n          shaky: {\n            distortFactor1: 1,\n            distortFactor2: 0.2,\n          }\n          ...\n    \n          is turned into that:\n    \n          ...\n          smoothy: () => fn({\n            distortFactor1: 1,\n            distortFactor2: 0.2,\n          }),\n          shaky: () => fn({\n            distortFactor1: 1,\n            distortFactor2: 0.2,\n          }),\n          ...\n    \n        */\n        //#region\n        return () => fn(innerObj);\n    }, obj);\n    debugLog('RES', res);\n    return res;\n};\nconst mapWithIndex = (0,es/* addIndex */.h0F)(es/* map */.UID);\nconst tuple = (...args) => args;\nconst noop = () => { };\nconst func_callAll = (...fns) => (...args) => {\n    let lastReturnVal = undefined;\n    fns.filter(Boolean).forEach((fn) => {\n        lastReturnVal = fn.apply(null, args);\n    });\n    return lastReturnVal;\n};\nconst isFunction = (val) => Object.prototype.toString.call(val) === '[object Function]';\nconst waitMs = (ms = 0) => new Promise((resolve) => setTimeout(resolve, ms));\nconst checkUntilTrue = async (cond, //Func<any, boolean>,\ntimeoutMs = 1000, checkEveryMs = 50) => {\n    return new Promise(async (resolve) => {\n        const timeout = setTimeout(resolve, timeoutMs);\n        while (await !cond())\n            await waitMs(checkEveryMs);\n        clearTimeout(timeout);\n        resolve();\n    });\n};\n/** For elements with anchors/offsets */\nconst getUIElementActualPos = (el) => {\n    const { offsetX, offsetY } = (0,es/* compose */.qCK)((0,es/* defaultTo */.yAE)({ offsetX: 0, offsetY: 0 }), (0,es/* path */.ETc)(['_anchor']))(el);\n    // TODO: take into account also 'panel._anchor.alignY' for the equation to be correct?\n    return {\n        x: el.x + offsetX,\n        y: el.y + offsetY,\n    };\n};\nsetGlobalVar(getUIElementActualPos);\nconst toFixedFloat = (n, precision = 5) => parseFloat(n.toFixed(precision));\nconst normalizeFloat = (n, precision = 2) => parseFloat(n.toFixed(precision));\nconst asArray = (val) => (val instanceof Array ? val : [val]);\nconst isUndefined = (val) => val === undefined;\nconst func_isDefined = (val) => val !== undefined;\nconst propIsDefined = (key) => (0,es/* compose */.qCK)((0,es/* complement */.CyQ)(isUndefined), (0,es/* prop */.vgT)(key), (0,es/* defaultTo */.yAE)({}));\nconst getPropWhenExists = (key, ...objects) => {\n    const obj = (0,es/* find */.sEJ)(propIsDefined(key), objects);\n    return obj ? obj[key] : undefined;\n};\nconst getPropWhenExistsOr = (defaultVal, key, ...objects) => {\n    return (getPropWhenExists(key, ...objects) || defaultVal);\n};\nconst defer = (cb, timeout) => setTimeout(cb, timeout);\nconst addSelfUntilSumIsInteger = (floatNum, maxIterations = 15) => {\n    const self = {\n        sum: 0,\n        iters: 0,\n        add: () => {\n            self.sum = parseFloat((floatNum * self.iters).toFixed(2));\n            self.iters += 1;\n        },\n        reset: () => (self.sum = 0),\n        run: () => {\n            while (self.sum === 0 ||\n                // (self.sum - parseInt(self.sum as any) < 0.151) &&\n                (self.sum !== parseInt(self.sum) && self.iters < maxIterations)) {\n                self.add();\n            }\n        },\n    };\n    return self;\n};\nexposeToWindow({ basedOnRanges, propIsDefined, getPropWhenExists, getPropWhenExistsOr });\nconst toggleGameObjVisible = (obj) => obj.setVisible(!obj.visible);\n\n;// CONCATENATED MODULE: ./src/common/types.ts\nclass types_PostFXPipeline extends Phaser.Renderer.WebGL.Pipelines.PostFXPipeline {\n}\nclass WebGLPipeline extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline {\n}\nconst types_Easing = Phaser.Math.Easing;\nconst getMatterBody = (obj) => obj.body;\nvar Geom;\n(function (Geom) {\n    Phaser.Geom;\n})(Geom || (Geom = {}));\nconst Star = Phaser.GameObjects.Star;\n// import RBush from 'rbush'\n// export type RTreeBBox = {}\n// export interface IPhaserRTree<T> extends Omit<RBush<T>, 'search'> {\n//   search: (bbox: RTreeBBox) => {}\n// }\nconst KeyCodes = Phaser.Input.Keyboard.KeyCodes;\nconst KeyboardEvents = Phaser.Input.Keyboard.Events;\nconst Keyboard = Phaser.Input.Keyboard;\n\n;// CONCATENATED MODULE: ./src/common/camera.ts\n\n\n\nconst CameraActions = {\n    panTo: (scene, { pos, duration = 1000, easing = types_Easing.Quadratic.Out, onComplete = noop, force = true, }) => {\n        return new Promise((resolve) => {\n            camera_mainCam(scene).pan(pos.x, pos.y, duration, easing, force);\n            camera_mainCam(scene).once(Phaser.Cameras.Scene2D.Events.PAN_COMPLETE, func_callAll(onComplete, resolve));\n        });\n    },\n    startFollow: (scene, objToFollow) => {\n        const LERP = 0.5;\n        camera_mainCam(scene).startFollow(objToFollow, false, LERP, LERP);\n    },\n};\n// TODO:\nconst smoothZoom = (scene, { zoom, duration, easing, onProgress, onComplete, }) => new Promise((resolve) => camera_mainCam(scene).zoomTo(zoom, defaultTo(2000, duration), defaultTo(Easing.Expo.InOut, easing), true, callAll(onProgress, (_, progress) => {\n    if (progress === 1) {\n        onComplete && onComplete();\n        resolve();\n    }\n})));\nconst fadeOut = (camera, duration) => {\n    return new Promise((resolve) => camera.fadeOut(duration, 0, 0, 0, () => {\n        resolve(null);\n    }));\n};\nconst fadeIn = (camera, duration) => {\n    return new Promise((resolve) => camera.fadeIn(duration, 0, 0, 0, () => {\n        resolve(null);\n    }));\n};\nconst camera_mainCam = (0,es/* path */.ETc)(['cameras', 'main']);\nconst mainCamViewport = (0,es/* compose */.qCK)((0,es/* pick */.eiS)(['x', 'y']), (0,es/* prop */.vgT)('worldView'), (0,es/* path */.ETc)(['cameras', 'main']));\nconst camScrollPos = (cam) => ({ x: cam.scrollX, y: cam.scrollY });\nconst mainCamScrollPos = (0,es/* compose */.qCK)((cam) => ({ scrollX: cam.scrollX, scrollY: cam.scrollY }), camera_mainCam);\nconst getCamScrollPos = (scene) => ({\n    x: camera_mainCam(scene).scrollX,\n    y: camera_mainCam(scene).scrollY,\n});\nexposeToWindow({ mainCam: camera_mainCam });\n\n;// CONCATENATED MODULE: ./src/common/screen.ts\n\n\n\nconst TARGET_FPS = 60;\n// NOTE!!!: .innerWidth and innerHeight yield STRANGE results (correct on phone - webview!); * but ALMOST!\n// when running on comp: in the Chrome dev tools (mobile) emulator! - use the actual monitor size???\n// while .outer* work OK!\nconst getWindowWH = () => ({\n    w: window.outerWidth,\n    h: window.outerHeight,\n});\n/** Useful for positioning texts */\nconst getCanvasWH = () => ({\n    w: getGameCanvas().width,\n    h: getGameCanvas().height,\n});\n/**\n * Returns 1 when the game is full-screen\n * E.g. if the game is on half-screen will return 0.5\n * Useful for e.g. dom buttons in phaer (to scale them accordingly\n * to the Canvas)\n */\nconst getCanvasScale = () => {\n    const c = getGameCanvas();\n    return parseInt(c.style.width) / c.width;\n};\nconst getCanvasCoordsInfo = () => {\n    const c = getGameCanvas();\n    const x = c.scrollLeft;\n    const y = c.scrollTop;\n    const w = parseInt(c.style.width);\n    const h = parseInt(c.style.height);\n    const centerPoint = { x: x + w / 2, y: y - h / 2 };\n    return {\n        centerPoint,\n        pos: { x, y },\n        size: { w, h },\n    };\n};\nconst getScreenRatio = () => Math.max(getWindowWH().w, getWindowWH().h) / Math.min(getWindowWH().w, getWindowWH().h);\nconst IMAGE_DPR = 2; // the  the max DPR -> scale all down to it\nconst DPR_MAX = 2; // if bigger, 2 will be used\nconst DPR_MIN = 2; // NOTE: try with 2 or 4 -> or\nconst DPR = Math.min(DPR_MAX, Math.max(window.devicePixelRatio, DPR_MIN));\nconst IMG_SCALE_TO_DPR = IMAGE_DPR / DPR;\nconst getBiggerDimension = () => Math.max(getWindowWH().w, getWindowWH().h) * DPR;\nconst getSmallerDimension = () => Math.min(getWindowWH().w, getWindowWH().h) * DPR;\nconst getGameCanvas = () => document.querySelector('#game canvas');\nconst getWorldBounds = (scene) => scene.cameras.main.getBounds();\n// export const recordCanvas = require('~/common/recordScreen').recordCanvas\n/**\n *  For this to work correctly, images should by default target the HIGHEST dpr we support: 4\n *  E.g. need to be 1) resized to x4, then rescaled with this function every time they are created\n *  or rescaled!\n * If param omitted, then scale the image to the default expectation: 1 by the DPRs\n */\nconst screen_getRelativeScale = (scaleTarget = 1) => scaleTarget / IMG_SCALE_TO_DPR;\n/** Useful for positioning of graphics objects */\nconst getByDpr = (size) => size / DPR;\nconst multipByDpr = (size) => size * DPR;\n// export const getScaleFactor = (scaleTarget: number = 1) => scaleTarget * IMG_SCALE_TO_DPR\nconst getDprX = (x) => x * DPR;\nconst getDprY = (y) => y * DPR;\nconst Rectangle = Phaser.Geom.Rectangle;\n/** Use for width/height of REX controls */\nconst __getDprFactorDueToNotPhone = () => 1; // isEmpty((window as any).cordova) ? 0.70 : 1\nconst ELECTRON_MAX_WIN_SIZE = {\n    w: 1920 / 2,\n    h: 1080 / 2,\n};\nconst screen_getScreenDprWidth = () => Math.min(1920, getWindowWH().w);\n// TODO: RE-ENABLE * DPR / *any-other-ratio (must be less than 2) to control game quality!\n// OLD - bad - breaks it bad for when Electron:\n// isElectron() ? Math.min(ELECTRON_MAX_WIN_SIZE.w, getWindowWH().w * DPR) : getWindowWH().w //* DPR\nconst screen_getScreenDprHeight = () => Math.min(1080, getWindowWH().h);\n// isElectron() ? Math.min(ELECTRON_MAX_WIN_SIZE.h, getWindowWH().h * DPR) : getWindowWH().h //* DPR\nconst getCanvasWidth = () => getCanvasWH().w;\nconst getCanvasHeight = () => getCanvasWH().h;\nconst getInstWidth = (obj) => obj.displayWidth;\nconst getInstHeight = (obj) => obj.displayHeight;\n/**\n *\n * @param pct The percentage 0 to 100\n * @param base The number to get percentage of; @default screen width\n * @returns\n */\nconst getCanvasPXWidthFromPct = (pct, base) => {\n    return defaultTo(screen_getScreenDprWidth(), base) * (pct / 100);\n};\n/**\n *\n * @param pct The percentage 0 to 100\n * @param base The number to get percentage of; @default screen height\n * @returns\n */\nconst getCanvasPXHeightFromPct = (pct, base) => {\n    return defaultTo(screen_getScreenDprHeight(), base) * (pct / 100);\n};\nconst getViewRectangle = (grow = 0) => {\n    const half = Math.max(0, grow / 2);\n    return new Rectangle(0 - half, 0 - half, screen_getScreenDprWidth() + grow, screen_getScreenDprHeight() + grow);\n};\nconst viewContainsPoint = (point, tolerance = 0) => {\n    return Rectangle.ContainsPoint(getViewRectangle(tolerance), point);\n};\nconst getPointOutsideView = (tolerance = 200 // TODO:DPR\n) => Rectangle.RandomOutside(getViewRectangle(tolerance), getViewRectangle());\nconst constrainInstToScreen = (inst, opts = { offset: 0 }) => {\n    const { offset } = opts;\n    const [WIDTH, HEIGHT] = [screen_getScreenDprWidth(), screen_getScreenDprHeight()];\n    const instW = getInstWidth(inst); // getDprX(this.inst.width)\n    const instH = getInstHeight(inst);\n    if (inst.x - (instW / 2 + offset) < 0) {\n        inst.x = instW / 2 + offset;\n    }\n    if (inst.y - (instH / 2 + offset) < 0) {\n        inst.y = instH / 2 + offset;\n    }\n    if (inst.x > WIDTH - (instW / 2 + offset)) {\n        inst.x = WIDTH - (instW / 2 + offset);\n    }\n    if (inst.y > HEIGHT - (instH / 2 + offset)) {\n        inst.y = HEIGHT - (instH / 2 + offset);\n    }\n};\nconst getTopCenter = (scene, offset = { x: 0, y: 0 }) => ({\n    // TODO: CHECK IF exchanging getScreenDprWidth with getCanvasWH().w has any issue?\n    x: getCanvasWH().w / 2 + offset.x,\n    y: 0 + offset.y,\n});\nconst getBottomCenter = (scene, offset = { x: 0, y: 0 }) => ({\n    x: getCanvasWidth() / 2 + offset.x,\n    y: getCanvasHeight() + offset.y,\n});\nconst getBottomLeft = (scene, offset = { x: 0, y: 0 }) => ({\n    x: 0 + offset.x,\n    y: getCanvasHeight() + offset.y,\n});\nconst getBottomRight = (scene, offset = { x: 0, y: 0 }) => ({\n    x: getCanvasWidth() + offset.x,\n    y: getCanvasHeight() + offset.y,\n});\nconst getCenterRight = (scene, offset = { x: 0, y: 0 }) => ({\n    x: getCanvasWidth() + offset.x,\n    y: getCanvasHeight() / 2 + offset.y,\n});\nconst getTopRight = (scene, offset = { x: 0, y: 0 }) => ({\n    x: getCanvasWidth() + offset.x,\n    y: 0 + offset.y,\n});\nconst getMidPoint = (scene, offset = { x: 0, y: 0 }) => ({\n    x: scene.scale.width / 2 + offset.x,\n    y: scene.scale.height / 2 + offset.y,\n});\nconst getCenterPoint = (/* unused pure expression or super */ null && (getMidPoint));\nsetGlobalVar(getMidPoint);\nconst getMaxWorldSize = (0,es/* always */.Bxt)(Infinity);\nconst getCoordOffset = (0,es/* always */.Bxt)(getMaxWorldSize() / 2);\nconst getCoordsForDisplay = (label, coordValue, divideBy = 1000) => {\n    const displayValue = coordValue / divideBy;\n    const shouldPad1Char = displayValue > 0;\n    return `${label}${shouldPad1Char ? ' ' : ''}${displayValue.toFixed(2)}`;\n};\nconst getGameObjectScreenMidPos = (scene, gameObject) => {\n    const mid = getMidPoint(scene, { x: gameObject.originX, y: gameObject.originX });\n    return {\n        x: mainCam(scene).scrollX + mid.x, // - gameObject.displayWidth / 2,\n        y: mainCam(scene).scrollY + mid.y, // - gameObject.displayHeight / 2,\n    };\n};\nconst getMonitorRefreshRate = (opts = {}) => new Promise((resolve) => {\n    var requestFrame = window.requestAnimationFrame;\n    if (!requestFrame)\n        return true; // Check if \"true\" is returned;\n    // pick default FPS, show error, etc...\n    function checker() {\n        if (index--)\n            requestFrame(checker);\n        else {\n            // var result = 3*Math.round(count*1000/3/(performance.now()-start));\n            var result = (count * 1000) / (performance.now() - start);\n            if (typeof opts.callback === 'function')\n                opts.callback(result);\n            resolve(result);\n        }\n    }\n    var count = opts.count || 60, index = count, start = performance.now();\n    checker();\n});\nsetGlobalVar(getMonitorRefreshRate);\nconst getConsistentRefreshRate = () => getGlobalVar('__FPS');\nconst getPhysicsUpdateFrameInd = () => getConsistentRefreshRate() / TARGET_FPS;\nsetGlobalVar(getPhysicsUpdateFrameInd);\n/**\n * Returns a boolean result whether the frame should be considered 'scene.update' regardless\n * the screen refresh rate (e.g. for 144hz this is every 2.4 frames)\n */\nconst isCorrectedUpdateFrame = () => { };\nconst getAndroidDeviceDisplayRate = () => {\n    return new Promise(async (resolve) => {\n        await window.device.getRefreshRate((res) => {\n            debugLog('RESULT', res);\n            resolve(res);\n        });\n        resolve(null); // FAIL\n    });\n};\n// const LOCAL_DEV_REFRESH_RATE = propOr(144, 'devRefreshRate')(localDevConfig)\n/** NO LONGER NEEDED ::: On Android, this will return the native refresh rate; if it fails -> returns null */\n// export const getDeviceRefreshRate = async () => {\n//   // NON ANDROID\n//   /// TODO: RE-enable after\n//   if (!getGlobalVar<any>('window').device || !getGlobalVar<any>('window').device.getRefreshRate) {\n//     return LOCAL_DEV_REFRESH_RATE\n//     const nonAndroidRes = await getMonitorRefreshRate({ count: 60 * 3 })\n//     return nonAndroidRes\n//   }\n//   let finalRes = null\n//   await checkUntilTrue(\n//     async () => {\n//       const res = await getAndroidDeviceDisplayRate()\n//       if (res) finalRes = res\n//       return finalRes === null\n//     },\n//     5000,\n//     500\n//   )\n//   debugLog('FINAL DEVICE REFRESH RATE: ', finalRes)\n//   return finalRes\n// }\n\n;// CONCATENATED MODULE: ./src/LD55/assets/crosshair-6.png\nconst crosshair_6_namespaceObject = __webpack_require__.p + \"63466bd0b41d9f847ed6.png\";\n;// CONCATENATED MODULE: ./src/LD55/assets/spacebar.png\nconst spacebar_namespaceObject = __webpack_require__.p + \"e117fea0a7225fb6ba0e.png\";\n;// CONCATENATED MODULE: ./src/LD55/assets/space-bug.png\nconst space_bug_namespaceObject = __webpack_require__.p + \"484871c03d11a4da1010.png\";\n;// CONCATENATED MODULE: ./src/LD55/assets/bug-small-sm.png\nconst bug_small_sm_namespaceObject = __webpack_require__.p + \"c78674f485d0b9bce1c8.png\";\n;// CONCATENATED MODULE: ./src/LD55/assets/spawn-circle.avif\nconst spawn_circle_namespaceObject = __webpack_require__.p + \"b7b53ce671a93259650f.avif\";\n;// CONCATENATED MODULE: ./src/LD55/assets/earth-sm.avif\nconst earth_sm_namespaceObject = __webpack_require__.p + \"182b23f8f75f0c3be702.avif\";\n;// CONCATENATED MODULE: ./src/LD55/assets/bonus-button.png\nconst bonus_button_namespaceObject = __webpack_require__.p + \"7a90d797badb869ea005.png\";\n;// CONCATENATED MODULE: ./src/LD55/assets/bonus-unsummon-sm.png\nconst bonus_unsummon_sm_namespaceObject = __webpack_require__.p + \"4a5efb40b114d80a5cf2.png\";\n;// CONCATENATED MODULE: ./assets/no-texture.png\nconst no_texture_namespaceObject = __webpack_require__.p + \"d5c3dbef69c712bf6f10.png\";\n;// CONCATENATED MODULE: ./src/common/scene.ts\n\n\nconst scene_SCENE_KEY = {\n    GAME_SCENE: 'GAME_SCENE',\n    BOOT_SCENE: 'BOOT_SCENE',\n    BACKGROUND_SCENE: 'BACKGROUND_SCENE',\n    FOREGROUND_SCENE: 'FOREGROUND_SCENE',\n    // STAR_GRAVITY_GAME: 'STAR_GRAVITY_GAME',\n}; // as Record<keyof typeof SCENE_KEY, any>\nconst BOOT_SCENE_KEY = 'BootScene';\n// todo: revise\nconst getByKey = (scene, key) => scene.scene.manager.getAt(scene.scene.manager.getIndex(key));\n// todo: revise\nconst sendToTop = (child) => child.scene && child.scene.children.bringToTop(child);\nconst sendToTopInOrder = (sceneChildren) => \n// reverse(sceneChildren).\nsceneChildren.forEach((child) => child.scene.children.bringToTop(child));\nconst sendToBack = (child) => child.scene && child.scene.children.sendToBack(child);\nconst SceneChildrenActions = {\n    sendToTop,\n    sendToTopInOrder,\n    sendToBack,\n};\n// export const sendABehindB = (scene: Scene, childA: any, childB) =>\n//   Phaser.Utils.Array.MoveBelow(scene.children, childA, childB)\nconst sendSceneToTop = (scene) => {\n    scene.scene.bringToTop(scene);\n};\nconst sendSceneToBack = (scene) => {\n    scene.scene.sendToBack(scene);\n};\nconst scene_TARGET_FPS = 60;\nconst getFPSFactor = (scene, \n/**\n * @power2 The magic change, in case we need Math.pow(fpsFactor, 2)\n * And this is the case when applying controls for example.. ?\n */\nconfig = { targetFPS: scene_TARGET_FPS, power2: false }) => {\n    return 1;\n    let actualFps = 1000 / scene.game.loop.delta;\n    // CALIBRATIONS / slight\n    if (actualFps < 65 && actualFps > 55)\n        actualFps = 60;\n    if (actualFps < 125 && actualFps > 115)\n        actualFps = 120;\n    ///////////////////////////\n    const [targetFPS, power2] = [\n        defaultTo(scene.matter.world.runner.fps, config.targetFPS),\n        defaultTo(false, config.power2),\n    ];\n    // NOTE: the MAGIC formula is THIS!\n    const factor = !power2 ? targetFPS / actualFps : Math.pow(targetFPS / actualFps, 2);\n    return useDebugConstant('fpsFactor', factor);\n};\n/**\n * @deprecated\n * @param givenFPS\n * @param config\n * @returns\n */\nconst getFPSFactorGivenFps = (givenFPS, config = { targetFPS: scene_TARGET_FPS }) => {\n    const factor = config.targetFPS / givenFPS;\n    return factor;\n};\nexposeToWindow({ sendToTop, sendToBack });\n\n;// CONCATENATED MODULE: ./src/textures/textures.ts\nconst INF_TEXTURE_COUNT = 50;\n// unused right now\nconst ANIMS_MAP = {\n    PARACHUTING: 'PARACHUTING',\n    PARACHUTE: 'PARACHUTE',\n    PARACHUTE_BLOW: 'PARACHUTE_BLOW',\n    PLR_RIP: 'PLR_RIP',\n    BORDER_ANIM: 'BORDER_ANIM',\n    BIRD_FLAPPING_1: 'BIRD_FLAPPING_1',\n    // UI\n    UI_GAME_BTN_START: 'UI_GAME_BTN_START',\n    UI_GAME_BTN_CONTINUE: 'UI_GAME_BTN_CONTINUE',\n};\nconst textures_TEXTURES_MAP = {\n    CROSSHAIR: 'CROSSHAIR',\n    SPACEBAR: 'SPACEBAR',\n    BUG_BIG: 'BUG_BIG',\n    BUG_SMALL: 'BUG_SMALL',\n    CREATION_CIRCLE: 'CREATION_CIRCLE',\n    EARTH: 'EARTH',\n    BTN_BASE: 'BTN_BASE',\n    BTN_UNSUMMON: 'BTN_UNSUMMON',\n    //\n    PLANE: 'PLANE',\n    SKY_BACKGROUND: 'SKY_BACKGROUND',\n    CLOUDS: 'CLOUDS',\n    CRATE: 'CRATE',\n    CRATE_WOOD: 'CRATE_WOOD',\n    CRATE_IRON: 'CRATE_IRON',\n    FLAG: 'FLAG',\n    GROUND1: 'GROUND1',\n    GROUND2: 'GROUND2',\n    EJECT_AREA: 'EJECT_AREA',\n    /////\n    NO_TEXTURE: 'NO_TEXTURE',\n    ELEM_ALL: 'ELEM_ALL',\n    WEAP_BULLET_1: 'WEAP_BULLET_1',\n    WEAP_SGM_BULLET_1: 'WEAP_SGM_BULLET_1',\n    WEAP_PISTOL_1: 'WEAP_PISTOL_1',\n    WEAP_SMG_1: 'WEAP_SMG_1',\n    WEAP_EXCALIBUR_1: 'WEAP_EXCALIBUR_1',\n    UI_GAME_BTN_START: 'UI_GAME_BTN_START',\n    UI_GAME_BTN_CONTINUE: 'UI_GAME_BTN_CONTINUE',\n    UI_GAME_BTN_SIMPLE_1: 'UI_GAME_BTN_SIMPLE_1',\n    BIRD_SPAWNER_1: 'BIRD_SPAWNER_1',\n    LOOT_BIRD_WING: 'LOOT_BIRD_WING',\n    LOOT_FEATHER: 'LOOT_FEATHER',\n    LOOT_FEATHER_GOLDEN: 'LOOT_FEATHER_GOLDEN',\n    BG_HILLS_1: 'BG_HILLS_1',\n    BIRD_FLAPPING: 'BIRD_FLAPPING',\n    ELEM_PARACHUTE: 'ELEM_PARACHUTE',\n    ELEM_PARACHUTE_BLOW: 'ELEM_PARACHUTE_BLOW',\n    ELEM_PARACHUTER: 'ELEM_PARACHUTER',\n    ELEM_BORDER: 'ELEM_BORDER',\n    ELEM_PARACHUTER_RIPPED: 'ELEM_PARACHUTER_RIPPED',\n    ELEM_WIN_BOTTOM_LINE: 'ELEM_WIN_BOTTOM_LINE',\n    ELEM_SPIKE1: 'ELEM_SPIKE1',\n};\n/** For when individual files have their own textures */\n// TODO: link all from here\nconst TEXTURES_FILES_MAP = {\n// [TEXTURES_MAP.InfBg[1]]: 'gal/bg-1.avif',\n// TODO:UPDATE\n// [TEXTURES_MAP.InfBg2]: \"nebulae_1.avif\",\n// [TEXTURES_MAP.InfBg3]: \"1pdn_2.avif\",\n// [TEXTURES_MAP.InfBg4]: \"sketch1633244048613_v1.avif\",\n// [TEXTURES_MAP.InfBg5]: \"sketch1633244048613_v2.avif\",\n// [TEXTURES_MAP.InfBg6]: \"sketch1633244048613_v3.avif\",\n// [TEXTURES_MAP.InfBg7]: \"sketch1633244048613_v4.avif\",\n// [TEXTURES_MAP.InfBg8]: \"sketch1633244048613_v5.avif\",\n// [TEXTURES_MAP.InfBg9]: \"sketch1633244048613_v6_alpha2.avif\",\n};\nconst getTextureFilePath = (key) => TEXTURES_FILES_MAP[key];\nconst TEXTURES_COLLIDE_ZONE = {\n    Asteroid: 200,\n};\nconst textureIsLoaded = (scene, key) => scene.textures.get(key) && scene.textures.get(key).key !== '__MISSING';\n// export const addB64Txt = (scene: Scene, key: TTextureKey, data: any) => {\n//   if (!textureIsLoaded(scene, key)) {\n//     scene.textures.addBase64(key, data);\n//   }\n// };\nconst getTxt = (scene, key) => scene.textures.get(key).get(0);\n\n;// CONCATENATED MODULE: ./src/common/fxPipeline.ts\n\n\n\n\nconst fxPipeline_createCustomPipeline = (game, fragShader, uniforms = {}) => {\n    return new CustomWebGlPipeline(game, fragShader, uniforms);\n};\n// const onPipelineRender = (inst: PipelineInst, scene: Scene) => {\n//   inst.parentScene = scene\n// }\nconst onPipelineBoot = (pipelineInst, uniforms = {}) => {\n    const inst = pipelineInst;\n    // important fix! - otherwise we get no color\n    inst.set2f(\"uResolution\", inst.game.config.width, inst.game.config.height);\n    // initial uniform values\n    (0,es/* forEach */.Ed_)((uniformKey) => {\n        const value = uniforms[uniformKey];\n        inst.set1f(uniformKey, value);\n    }, Object.keys(uniforms));\n};\nconst applyAndUpdateUniforms = (inst, uniforms) => {\n    Object.keys(uniforms).forEach((propKey) => {\n        const propValue = uniforms[propKey];\n        inst.set1f(propKey, propValue); // NOTE: may NOT be 1f !!!\n        inst.uniforms[propKey] = propValue; // manual update in the flags\n    });\n};\nconst setTimeUniform = (inst, time) => {\n    inst.set1f(\"uTime\", time);\n    inst.set1f(\"time\", time);\n};\nconst onPipelinePreRender = (pipelineInst) => {\n    const inst = pipelineInst;\n    // setGlobalVar('pipInstText', inst.gameObject && inst.gameObject.text)\n    // logGlobalVar('pipInstText')\n    if (\n    // COMMENT THIS OUT FOR NOW - the game object becomes active: false after the scene is restarted ???\n    // NO: it's an old reference - not sure why\n    // pathEq([ 'gameObject', 'active' ], false, inst) ||\n    !inst.active //|| inst.gameObject && !inst.gameObject.scene.scene.isActive() // TODO:FIX LATER\n    )\n        return;\n    if (inst.game) {\n        const actualFps = 1000 / inst.game.loop.delta;\n        const targetFPS = 60;\n        const incrementTime = targetFPS / actualFps;\n        const nextTime = inst.time + incrementTime / TARGET_FPS;\n        inst.time = nextTime;\n        // inst.time = nextTime > 15 ? 0 : nextTime; // this is of no use\n        setTimeUniform(inst, nextTime);\n    }\n};\nsetGlobalVar(setTimeUniform);\nconst asCustomPipeline = (inst) => inst;\nconst fxPipeline_createCustomPostFxPipeline = (game, fragShader, name, uniforms = {}) => {\n    const DEFAULT_UNIFORMS = { timeFactor: 1 };\n    // this is instantiated by a class, not by an instance, that's why create a new class:\n    return class CustomPostFxPipeline extends PostFXPipeline {\n        constructor() {\n            super({\n                game,\n                renderTarget: true,\n                // NOTE: do NOT pass a frag shader (or null) to fall back on the default shader,\n                // e.g. if want to use color matrix\n                fragShader,\n                name,\n                uniforms: [\n                    \"uProjectionMatrix\",\n                    \"uMainSampler\",\n                    \"uTime\",\n                    ...Object.keys(uniforms),\n                ],\n            });\n            this._internalFpsCounter = 0;\n            this.uniforms = { ...DEFAULT_UNIFORMS, ...uniforms };\n            this.name = name;\n            this.time = 0;\n            this.active = true;\n        }\n        /** Applies the uniforms to the shader and updates the `uniforms` object */\n        setUniforms(uniforms) {\n            applyAndUpdateUniforms.bind(this)(this, uniforms);\n        }\n        setTimeUniform(timeValue) {\n            this.time = 0;\n            setTimeUniform(this, timeValue);\n        }\n        onBind(gameObject) {\n            if (!this.gameObject)\n                this.gameObject = gameObject;\n        }\n        onPreRender() {\n            onPipelinePreRender(this);\n        }\n        onBoot() {\n            onPipelineBoot(this, uniforms);\n        }\n        onDraw(renderTarget) {\n            // NOTE: this enables the use of this.colorMatrix !\n            // super.onDraw.call(this, renderTarget)\n            this.drawFrame(renderTarget, this.fullFrame1);\n            this.bindAndDraw(this.fullFrame1);\n        }\n    };\n};\n/**\n * A custom utility class for creating custom pipelines\n * NOTE: this extends SinglePipeline instead of MultiPipeline which will work correctly on text objects\n */\nclass CustomWebGlPipeline extends Phaser.Renderer.WebGL.Pipelines.SinglePipeline {\n    constructor(game, fragShader, uniforms) {\n        super({\n            game,\n            fragShader,\n            uniforms: [\n                \"uProjectionMatrix\",\n                \"uViewMatrix\",\n                \"uModelMatrix\",\n                \"uMainSampler\",\n                \"uResolution\",\n                \"uTime\",\n                ...Object.keys(uniforms),\n            ],\n        });\n        this._internalFpsCounter = 0;\n        this.uniforms = {};\n        this.time = 0;\n        this.uniforms = uniforms;\n    }\n    /** Applies the uniforms to the shader and updates the `uniforms` object */\n    setUniforms(uniforms) {\n        applyAndUpdateUniforms(this, uniforms);\n    }\n    setTimeUniform(timeValue) {\n        this.time = timeValue;\n        setTimeUniform(this, this.time);\n    }\n    onBind(gameObject) {\n        if (!this.gameObject)\n            this.gameObject = gameObject;\n    }\n    onPreRender() {\n        // debugLog('ON PRERENDER', this.time)\n        onPipelinePreRender(this);\n    }\n    onBoot(...args) {\n        debug_debugLog(args);\n        onPipelineBoot(this);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/grayscale.frag\nconst grayscale_namespaceObject = __webpack_require__.p + \"51418e83535b819859a5.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/grayscale-notPost.frag\nconst grayscale_notPost_namespaceObject = __webpack_require__.p + \"a1436875ab3f404cb9d4.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/distortion.frag\nconst distortion_namespaceObject = __webpack_require__.p + \"a3da7432694f2284a0ee.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/distortion2.frag\nconst distortion2_namespaceObject = __webpack_require__.p + \"c4dd1cfcc0b8685bdfc0.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/abstract-waves/abstract-waves.frag\nconst abstract_waves_namespaceObject = __webpack_require__.p + \"31cd772a96837a9316a1.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/galaxy.frag\nconst galaxy_namespaceObject = __webpack_require__.p + \"ff9574ab949c5b3efc3c.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/cloud-smoke/smoke-greenish.frag\nconst smoke_greenish_namespaceObject = __webpack_require__.p + \"5623277ae8284a2fe5d3.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/text/text-recolor-1.frag\nconst text_recolor_1_namespaceObject = __webpack_require__.p + \"6460a263c3139a34bfd6.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/distortion/bend.frag\nconst bend_namespaceObject = __webpack_require__.p + \"56f500ef2c4d2ab4c53a.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/text/hueRotate.frag\nconst hueRotate_namespaceObject = __webpack_require__.p + \"575ea9c5198d3d572200.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/text/hueRotatePost.frag\nconst hueRotatePost_namespaceObject = __webpack_require__.p + \"599e78cec587dde00c93.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/postFx/simple-blur.frag\nconst simple_blur_namespaceObject = __webpack_require__.p + \"010d2e59f72d7086f8b8.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/postFx/glsl-fast-gaussian-blur.frag\nconst glsl_fast_gaussian_blur_namespaceObject = __webpack_require__.p + \"9c7c5ec0e8e5a76c3bde.frag\";\n;// CONCATENATED MODULE: ./src/fx/pipelines/frag/index.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/fx/pipelines/pipelines.ts\n\n\n\n\nconst pipelines_Pipelines = {\n    grayPost: 'grayPost',\n    distortionPost: 'distortionPost',\n    distortion2Post: 'distortion2Post',\n    cosmicGlow: 'cosmicGlow',\n    galaxy: 'galaxy',\n    galaxyPost: 'galaxyPost',\n    smokeGreenishPost: 'smokeGreenishPost',\n    textRecolor: 'textRecolor',\n    textRecolorPost: 'textRecolorPost',\n    bend: 'bend',\n    basePost: 'basePost',\n    bendPost: 'bendPost',\n    hueRotate: 'hueRotate',\n    hueRotatePost: 'hueRotatePost',\n    simpleBlur: 'simpleBlur',\n    gaussianBlur: 'gaussianBlur',\n    gaussianBlurPost: 'gaussianBlurPost'\n};\nconst DEFAULT_PIPELINE_UNIFORMS = {\n    [pipelines_Pipelines.cosmicGlow]: {},\n    [pipelines_Pipelines.grayPost]: {\n        gray: 1,\n    },\n    [pipelines_Pipelines.distortionPost]: {\n        timeFactor: 1,\n    },\n    [pipelines_Pipelines.distortion2Post]: {\n        timeFactor: 1,\n        uSpeed: 0.3,\n        uBendFactor: 0.003,\n    },\n    [pipelines_Pipelines.simpleBlur]: {\n        blur: 0.005,\n    },\n    [pipelines_Pipelines.gaussianBlur]: {\n    // TODO\n    },\n    [pipelines_Pipelines.gaussianBlurPost]: {\n    // TODO\n    },\n};\nconst getWebGlRenderer = (scene) => scene.renderer;\nconst addPipeline = (scene, name, instance) => getWebGlRenderer(scene).pipelines.add(name, instance);\nconst addPostPipeline = (scene, name, _class) => getWebGlRenderer(scene).pipelines.addPostPipeline(name, _class);\nconst formPipelineCreateArgs = (type, frag) => ({\n    [type]: [frag, DEFAULT_PIPELINE_UNIFORMS[type]],\n});\nconst PIPELINE_ARGS = {\n    ...formPipelineCreateArgs(pipelines_Pipelines.basePost, undefined), // SPECIAL: use the default fragShader!\n    ...formPipelineCreateArgs(pipelines_Pipelines.cosmicGlow, abstract_waves_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.grayPost, grayscale_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.distortionPost, distortion_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.distortion2Post, distortion2_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.galaxy, galaxy_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.galaxyPost, galaxy_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.smokeGreenishPost, smoke_greenish_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.textRecolor, text_recolor_1_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.textRecolorPost, text_recolor_1_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.bend, bend_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.bendPost, bend_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.hueRotate, hueRotate_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.hueRotatePost, hueRotatePost_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.simpleBlur, simple_blur_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.gaussianBlur, glsl_fast_gaussian_blur_namespaceObject),\n    ...formPipelineCreateArgs(pipelines_Pipelines.gaussianBlurPost, glsl_fast_gaussian_blur_namespaceObject),\n};\n/** Adds a pipeline or post pipeline for use in the scene */\nconst pipelines_pipelineFactory = (scene, name, isPostPipeline = false, uniforms) => {\n    if (!isPostPipeline && checkPipelineExists(scene, name, isPostPipeline)) {\n        debugWarn('Pipeline already exists: ', name);\n        return;\n    }\n    const pipelineArgs = PIPELINE_ARGS[name];\n    if (!pipelineArgs)\n        throw new Error('No configuration for pipeline: ' + name);\n    pipelineArgs[1] = merge(pipelineArgs[1], uniforms || {});\n    if (!isPostPipeline) {\n        // TODO: check if such class already exists!\n        const pipeline = createCustomPipeline.apply(null, [scene.game, ...pipelineArgs]);\n        // add it to the usable pipelines and return the instance\n        const newPipelineInst = addPipeline(scene, name, pipeline);\n        return newPipelineInst;\n    }\n    else {\n        const PipelineClass = createCustomPostFxPipeline(scene.game, pipelineArgs[0], name, pipelineArgs[1]);\n        // add it to the usable pipelines\n        addPostPipeline(scene, name, PipelineClass);\n        // createPostPipelineInstance(scene, name)\n        // return the instance\n        return undefined;\n    }\n};\nconst checkPipelineExists = (scene, name, isPostPipeline = false) => isPostPipeline\n    ? getWebGlRenderer(scene).pipelines.getPostPipeline(name)\n    : getWebGlRenderer(scene).pipelines.get(name);\nconst checkPostPipelineExists = (scene, name) => checkPipelineExists(scene, name, true);\nconst createGrayScalePipeline = (game) => createCustomPipeline(game, frags.grayscaleNotPost, {\n    gray: 1,\n    factor: 0.1,\n});\nconst createGrayScalePostPipeline = (game) => createCustomPostFxPipeline(game, frags.grayscale, {\n    gray: 1,\n});\nconst createDistortionPostPipeline = (game) => createCustomPostFxPipeline(game, frags.distortion1, pipelines_Pipelines.distortionPost);\n// export const createDistortion2PostPipeline = (game: Game) => createCustomPostFxPipeline(game, frags.distortion2)\nconst createPostPipelineInstance = (scene, key) => getWebGlRenderer(scene).pipelines.getPostPipeline(key);\nconst findPostPipelineInstance = (scene, key) => getWebGlRenderer(scene).pipelines.postPipelineClasses.get(key);\nconst findPipelineInstance = (scene, key) => getWebGlRenderer(scene).pipelines.classes.get(key);\nconst createDistortionPipeline = (game) => createCustomPipeline(game, frags.distortion1, {\n// gray: 1,\n// factor: 0.1\n});\n\n;// CONCATENATED MODULE: ./src/scenes/common.ts\n\n\n\n\nconst common_getGameCanvas = () => document.querySelector('#game canvas');\nconst getGameScene = (scene) => scene.scene.get(SCENE_KEY.GAME_SCENE);\nconst getForegroundScene = (scene) => scene.scene.get(SCENE_KEY.FOREGROUND_SCENE);\nconst getScene = (scene, key) => scene.scene.get(key);\nconst findSceneByKey = (game, key) => game.scene.scenes.find((0,es/* pathEq */.uF6)(['scene', 'key'], key));\nsetGlobalVar(findSceneByKey);\nconst startScene = (game, sceneKey) => {\n    const targetScene = game.scene.scenes.find((0,es/* pathEq */.uF6)(['scene', 'key'], sceneKey));\n    targetScene.scene.start();\n    return targetScene;\n};\nconst registerPipelines = (scene) => {\n    if (scene.renderer.type !== Phaser.WEBGL) {\n        debugWarn('Not a WEBGL renderer');\n        return;\n    }\n    // pipelineFactory(scene, Pipelines.basePost, true)\n    // pipelineFactory(scene, Pipelines.grayPost, true)\n    pipelineFactory(scene, Pipelines.textRecolor, false, { timeFactor: 5 });\n    // pipelineFactory(scene, Pipelines.simpleBlur, false, { blur: 0.001 })\n    // pipelineFactory(scene, Pipelines.gaussianBlur, false, {})\n    // pipelineFactory(scene, Pipelines.gaussianBlurPost, true, {})\n    // pipelineFactory(scene, Pipelines.distortionPost, true, {\n    //   applyHueRotation: false,\n    //   distortFactor1: 0.5,\n    //   sinFactor1: 5,\n    //   sinTimeFactor1: 0.1,\n    //   distortFactor2: 0.2,\n    //   sinFactor2: 32,\n    //   sinTimeFactor2: 0.01,\n    // })\n    // pipelineFactory(scene, Pipelines.cosmicGlow, true)\n    // pipelineFactory(scene, Pipelines.distortion2Post, true)\n    // pipelineFactory(scene, Pipelines.galaxyPost, true)\n    // pipelineFactory(scene, Pipelines.smokeGreenishPost, true)\n    // pipelineFactory(scene, Pipelines.textRecolorPost, true)\n    // // pipelineFactory(scene, Pipelines.bend, false, { bendFactor: 1 })\n    // // TODO: presets based on uBendFactor: 0.1\n    // /*\n    //       def: { uBendFactor: 0.3, uSpeed: 0.4, timeFactor: 3 })\n    //       0.1  slight lean\n    //       0.1 + spd 4.4  jiggly jiggle\n    //       0.3 +\n    //       5  ultra bend\n    //     */\n    // pipelineFactory(scene, Pipelines.bendPost, true, { uBendFactor: 0.1, uSpeed: 4.4, timeFactor: 3 })\n    // /** */\n    // pipelineFactory(scene, Pipelines.hueRotatePost, true, { uSpeed: 1 })\n    // pipelineFactory(scene, Pipelines.hueRotate, true, { uSpeed: 1 })\n};\n\n// EXTERNAL MODULE: ./node_modules/obs-disp/dist/index.js + 8 modules\nvar dist = __webpack_require__(631);\n;// CONCATENATED MODULE: ./src/OD.ts\n\n\n\nconst ODAPI = (0,dist/* createAPI */.rk)({\n    //// for debugging\n    onEvent: (ev) => ![\n        'UPDATE',\n        'POST_UPDATE',\n        'INPUT_UPDATE',\n        'INPUT_UPDATE_STATE',\n        'GAME_UPDATE',\n        'POST_UPDATE_THROTTLED',\n        'HTML_EV_ANY',\n    ].includes(ev.name) && console.log('EVENT DISP', ev),\n    onObsCreated: (obs) => console.log('OBS ADDED', obs),\n    onObsRemoved: (obs) => console.log('OBS REMOVED', obs),\n    onWarn: (args) => console.log('WARN: ', args?.msg, args?.params),\n});\nconst { ObsDispCreate, obsDispEvents, payloadPropOr, payloadProp, payload, constructEvents, } = dist;\nconst { addObsDisp, dispatchEvent, dispatchDeferredEvent, removeObs, obsDispCreator, removeObsById, removeAllObservers, createThrottledDispatch, getAllObservers, } = ODAPI;\nexposeToWindow({ OD: ODAPI }); // for tinkering only - expose the whole API\nconst getObserversByName = (name) => ODAPI.getAllObservers().filter((o) => o.options?.name === name);\n\n// EXTERNAL MODULE: ./node_modules/throttle-debounce/esm/index.js\nvar esm = __webpack_require__(856);\n;// CONCATENATED MODULE: ./src/common/throttle.ts\n\nconst throttle = (ms, callback, opts) => {\n    return (0,esm/* throttle */.P)(ms, callback, opts);\n};\n\n/* harmony default export */ const common_throttle = (throttle);\n\n;// CONCATENATED MODULE: ./src/events/sceneEvents.ts\n\nconst sceneEvents = (0,dist.constructEvents)([\n    'CREATE',\n    'CORRECTED_UPDATE',\n    'DESTROY',\n    'UPDATE',\n    'POST_UPDATE',\n    'POST_UPDATE_THROTTLED',\n    'CAMERA_SCROLL_CHANGE',\n    // CUSTOM\n    'RESIZE_WORLD',\n    'SCENE_SET_CINEMATIC_ACTIVE',\n    'DRAW_HALT',\n    'DRAW_RESUME',\n]);\n\n;// CONCATENATED MODULE: ./src/scenes/BaseObservableScene.ts\n\n\n\n\n\nconst ObservableScenes = {\n    game: null,\n    foreground: null,\n    background: null,\n    bootScene: null,\n};\nexposeToWindow({ ObservableScenes });\n/**\n * The fixed time-step\n * */\nconst BaseObservableScene_TARGET_FPS = 60;\nconst FPS_DELTA = 1000 / BaseObservableScene_TARGET_FPS;\n/** Used to dispatch given events only from one scene */\nlet _FIRST_SCENE_KEY = null;\n/** Use to create all scenes - makes sure MatterJS physics are fixed (diff refresh rate) */\nconst createObservableScene = (config) => {\n    const { createObservers, key, onCreate, onPreload } = config;\n    if (!_FIRST_SCENE_KEY)\n        _FIRST_SCENE_KEY = key;\n    return class ObservableScene extends Phaser.Scene {\n        constructor() {\n            super({\n                key,\n            });\n            this.observers = [];\n            //////// ->\n            //  HIGHER-MONITOR-REFRESH-RATE-ISSUES:SOLVED: have autoUpdate: false, fps: 60 and .step:\n            this._deltaAccum = 0;\n            this._isUpdatingThisStep = false;\n            this.postUpdate = (...args) => {\n                key === _FIRST_SCENE_KEY &&\n                    dispatchEvent(sceneEvents.POST_UPDATE, {\n                        payload: {\n                            isUpdatingThisStep: this._isUpdatingThisStep,\n                        },\n                    });\n            };\n            // TODO: dispatch to ALL !!!\n            this.postUpdateThrottled = common_throttle(50, () => {\n                key === _FIRST_SCENE_KEY && dispatchEvent(sceneEvents.POST_UPDATE_THROTTLED);\n            });\n        }\n        /**\n         * Makes sure that events are dispatched to the globalObservable as well\n         * (only from one scene)\n         */\n        // private _dispatchEvent: typeof dispatchEvent = (...args) => {\n        //   // dispatchEvent(this.observable, args[1], args[2])\n        //   // _FIRST_SCENE_KEY === key && dispatchEvent(globalObservable, args[1], args[2])\n        //   dispatchEvent(this.observable, args[1])\n        //   // _FIRST_SCENE_KEY === key && dispatchEvent(globalObservable, args[1])\n        // }\n        // public observable: IObservable = { observers: [] }\n        // public mainSceneObservable: IObservable // TODO: to be able to retrieve\n        async preload() {\n            onPreload && onPreload(this);\n        }\n        create() {\n            ///// update global scene accessor\n            switchOn({\n                GAME_SCENE: () => (ObservableScenes.game = this),\n                BACKGROUND_SCENE: () => (ObservableScenes.background = this),\n                FOREGROUND_SCENE: () => (ObservableScenes.foreground = this),\n                BOOT_SCENE: () => (ObservableScenes.bootScene = this),\n            })(key);\n            // storeObservable(this.observable)\n            this.observers = createObservers(this);\n            dispatchEvent(sceneEvents.CREATE, { payload: { key } });\n            this.scene.scene.events.on('destroy', () => {\n                this.observers.forEach((o) => removeObs(o));\n                this.observers = [];\n                dispatchEvent(sceneEvents.DESTROY, { payload: { key } });\n            });\n            this.scene.scene.events.addListener(Phaser.Scenes.Events.POST_UPDATE, func_callAll(this.postUpdate, this.postUpdateThrottled));\n            onCreate && onCreate(this);\n        }\n        update(time, delta) {\n            const currentFPS = 1000 / delta;\n            const currentFPSFactor = BaseObservableScene_TARGET_FPS / currentFPS;\n            //  HIGHER-MONITOR-REFRESH-RATE-ISSUES:SOLVED: simulation visual speed\n            this.matter.world.engine.timing.timeScale = currentFPSFactor;\n            this._deltaAccum += delta;\n            this._isUpdatingThisStep = this._deltaAccum > FPS_DELTA;\n            if (this._deltaAccum > FPS_DELTA) {\n                this._deltaAccum -= FPS_DELTA;\n                // if (this.matter.world.enabled) {\n                //  HIGHER-MONITOR-REFRESH-RATE-ISSUES:SOLVED: UPDATE to always be dispatched 60 times per second\n                key === _FIRST_SCENE_KEY &&\n                    dispatchEvent(sceneEvents.UPDATE, {\n                        payload: {\n                            time,\n                            delta,\n                            deltaAccum: this._deltaAccum,\n                            currentFPSFactor,\n                        },\n                    });\n                // }\n            }\n        }\n    };\n};\n\n;// CONCATENATED MODULE: ./src/events/gameEvents.ts\n\nconst gameEvents = (0,dist.constructEvents)([\n    'GAME_START',\n    'GAME_EDIT',\n    'GAME_EDIT_EXIT',\n    'GAME_RESTART',\n    'GAME_REQUEST_RESTART',\n    'CRATE_EJECT',\n    //\n    'SCREEN_GO_TO_BEFORE_GAME',\n    'SCREEN_GO_TO_GAME',\n    'LEVEL_SET_LEVEL',\n    'GAME_END',\n    'GAME_FAILED',\n    'GAME_WON',\n    'GAME_PAUSE',\n    'GAME_RESUME',\n    //\n    'GAME_ENGINE_SET_SCOPE',\n    'GAME_FLOW_GO_TO_MENU',\n    'GAME_ADVANCE',\n    'GAME_DID_ADVANCE',\n    'GAME_PART_START',\n    'GAME_PART_END',\n    'GAME_LEVEL_CLEAR',\n    'GAME_LEVEL_STARTED',\n    'GAME_LEVEL_ENDED',\n    'GAME_LEVEL_RESTART',\n    'GAME_LOST',\n    'GAME_LIFE_LOST',\n    'GAME_PLR_RESTARTED',\n    'GAME_PLR_OFF_BOTTOM',\n    'GAME_PLR_RIP',\n    'GAME_PLR_LOST_LIVE',\n]);\n\n;// CONCATENATED MODULE: ./src/core/ConfigWorld.ts\n\n\n\n\n\n\nconst ConfigWorldEvents = {\n    resizeWorld: (size) => {\n        dispatchDeferredEvent(sceneEvents.RESIZE_WORLD, { payload: { size } });\n    },\n};\nexposeToWindow({ ConfigWorldEvents });\nconst initConfigWorld = (scene) => {\n    const _state = {\n        worldSize: null,\n        viewportSize: null,\n    };\n    return addObsDisp(() => {\n        const handleResizeWorld = (ev) => {\n            const worldSize = {\n                w: (0,dist/* payloadPathOr */.k9)('size.w', Infinity /*  getScreenDprWidth() */)(ev),\n                h: (0,dist/* payloadPathOr */.k9)('size.h', Infinity /*  getScreenDprWidth() */)(ev),\n            };\n            _state.worldSize = worldSize;\n            exposeToWindow({ worldSize });\n            // scene.cameras.main.roundPixels = true\n            //#region ////////////// CAMERA/ WORLD SIZES fix\n            const canvas = getGameCanvas();\n            scene.cameras.main.setViewport(0, 0, canvas.width, canvas.height);\n            _state.viewportSize = { w: canvas.width, h: canvas.height };\n            // NOTE:DEBUG\n            // NOTE: do NOT set camera bounds, if dealing with an \"infinite\" world\n            // NOTE 2: set it if the camera should be limited into some given area...\n            // mainCam(scene).setBounds(worldSize.w / 2, worldSize.h, worldSize.w, worldSize.h)\n            scene.matter.world.setBounds(worldSize.w / 2, worldSize.h / 2, worldSize.w, worldSize.h, 1);\n            // NO NEED FOR setBounds if we dont need walls\n            // scene.matter.world.setBounds(\n            //   0,\n            //   0,\n            //   worldSize.w * 1000,\n            //   worldSize.h * 1000, // REMOVING WALLS THE UGLY WAY\n            //   64,\n            //   // disabling ALL walls for now\n            //   false,\n            //   false,\n            //   false,\n            //   false\n            // )\n        };\n        return {\n            [sceneEvents.RESIZE_WORLD]: handleResizeWorld,\n            [gameEvents.GAME_PLR_RESTARTED]: (ev) => {\n                // const plr = payloadPropOr('player', null)(ev) as Sprite\n                // plr = plr\n            },\n            // TODO:D:NOW - move this POST_UPDATE-CAM_FOLLOW LOGIC to the ParachuterObserver\n            //// NOTE: fixed via `PlayerSingleton.instanceExists()` ->\n            [sceneEvents.POST_UPDATE]: () => {\n                //////////////////////////////////////////////////////////////////////////////\n                //////////    NB     ALL THE LOGIC BELOW IS  SOLVED VIA SETTING PROPER  camera bounds\n                // e.g. x: 0y : 0 will make it such that 0,0 coords are bounds of camera..\n                // mainCam(scene).setBounds(worldSize.w / 2, worldSize.h, worldSize.w, worldSize.h)\n                //\n                ///////////////////////////////\n                return;\n            },\n        };\n    });\n};\n\n;// CONCATENATED MODULE: ./src/events/inputEvents.ts\n\nconst inputEvents = (0,dist.constructEvents)([\n    'INPUT_UPDATE_STATE',\n    'KEY_LEFT',\n    'KEY_RIGHT',\n    'KEY_UP',\n    'KEY_DOWN',\n    //\n    'BUTTON_CLICK',\n    'SWIPE',\n    'DRAG_LEFT',\n    'DRAG_RIGHT',\n    'DRAG_UP',\n    'DRAG_DOWN',\n    'LOCAL_PAN',\n    'LOCAL_PAN_END',\n    'GLOBAL_POINTER_DOWN',\n    'GLOBAL_POINTER_UP',\n    'GLOBAL_PAN',\n    'GLOBAL_PAN_END',\n    'GLOBAL_TAP_SINGLE',\n    'DOUBLE_BUFFERED_GLOBAL_TAP_SINGLE',\n    'PREVENT_DOUBLE_BUFFERED_GLOBAL_TAP_SINGLE',\n    'GLOBAL_PINCH',\n    'EDGE_SLIDE',\n    'EDGE_SLIDE_END',\n    'INPUT_PREVENT_GLOBAL_PAN_SINGLE',\n    'INPUT_SCREEN_RESIZE',\n]);\n\n;// CONCATENATED MODULE: ./src/core/InputDispatcherObserver.ts\n\n\n\n\n\n\n// import { createThrottledDispatch, dispatchEvent } from '~/OD'\nconst initInputDispatcherObserver = (getIsOverObj = (0,es/* always */.Bxt)(false)) => (scene) => {\n    return addObsDisp(() => {\n        const _state = {\n            keys: {},\n            down: false,\n            up: false,\n            space: false,\n            inEdgeSlide: false,\n            firstMouseDownInObj: null,\n            firstMouseDownPointer: null,\n            lastPointerPos: null,\n            lastPointerPosThrottled: null,\n            preventDoubleBufferedSingleTap: false,\n            preventGlobalPanSingle: false,\n        };\n        // TODO: create the touch controls - and use them!\n        // scene.input.keyboard.on('keydown-A', () => {\n        //   dispatchEvent(inputEvents.DRAG_LEFT)\n        // })\n        // scene.input.keyboard.on('keydown-D', () => {\n        //   dispatchEvent(inputEvents.DRAG_RIGHT)\n        // })\n        scene.input.on(Phaser.Input.Events.POINTER_DOWN, (pointer) => {\n            _state.firstMouseDownPointer = scene.input.activePointer;\n            const objOver = getIsOverObj(scene, scene.input.activePointer);\n            _state.firstMouseDownInObj = objOver;\n            if (!_state.firstMouseDownInObj) {\n                dispatchEvent(inputEvents.GLOBAL_POINTER_DOWN, {\n                    payload: {\n                        pointer,\n                        localPos: (0,es/* pick */.eiS)(['x', 'y'], scene.input.activePointer.position),\n                        worldPos: {\n                            x: scene.input.activePointer.worldX,\n                            y: scene.input.activePointer.worldY,\n                        },\n                    },\n                });\n            }\n        });\n        scene.input.on(Phaser.Input.Events.POINTER_UP, (pointer) => {\n            // debugLog('args', pointer.position, pointer.prevPosition)\n            // debugLog('_state.lastPointerPos', _state.lastPointerPos)\n            _state.firstMouseDownPointer = null;\n            if (!_state.firstMouseDownInObj) {\n                dispatchEvent(inputEvents.GLOBAL_POINTER_UP);\n            }\n        });\n        const dispatchScreenResize = common_throttle(200, (...args) => dispatchEvent(inputEvents.INPUT_SCREEN_RESIZE, ...args));\n        window.onresize = () => {\n            dispatchScreenResize({\n                payload: getCanvasCoordsInfo(),\n            });\n        };\n        // INITIAL\n        dispatchScreenResize({\n            payload: getCanvasCoordsInfo(),\n        });\n        const createSwipeEvent = (ev, swipe) => {\n            // debugLog('VELO', swipe.dragVelocity)\n            return {\n                ...ev,\n                payload: {\n                    velocity: swipe.dragVelocity,\n                },\n            };\n        };\n        const createPanEvent = (ev, firstMouseDown, isOverObj, args) => {\n            return {\n                ...ev,\n                payload: {\n                    firstMouseDown,\n                    pan: args[0],\n                    gameObject: isOverObj || args[1],\n                    lastPointer: args[2],\n                },\n            };\n        };\n        const createGlobalTapEvent = (ev, firstMouseDown, args) => {\n            return {\n                ...ev,\n                payload: {\n                    firstMouseDown,\n                    evArgs: args,\n                },\n            };\n        };\n        const createGlobalPinchEvent = (ev, args) => {\n            return {\n                ...ev,\n                payload: {\n                    evArgs: args,\n                },\n            };\n        };\n        return {\n            HTML_EV_ANY: ({ payload }) => {\n                // console.log(payload.type, payload)\n                const key = payload.wrappedEventArgs[0].key;\n                const event = payload.wrappedEventArgs[0];\n                basedOnPartial({\n                    keydown: () => {\n                        event.preventDefault();\n                        console.log('key', key);\n                        _state.keys[key] = true;\n                        basedOnPartial({\n                            // ArrowLeft: () =>  (_state.left = true),\n                            ArrowDown: () => (_state.down = true),\n                            ArrowUp: () => (_state.up = true),\n                            ' ': () => (_state.space = true),\n                        })(key);\n                    },\n                    keyup: () => {\n                        event.preventDefault();\n                        _state.keys[key] = false;\n                        basedOnPartial({\n                            // ArrowLeft: () => (_state.left = false),\n                            ArrowDown: () => (_state.down = false),\n                            ArrowUp: () => (_state.up = false),\n                            ' ': () => (_state.space = false),\n                            // ArrowRight: () => (_state.right = false),\n                        })(key);\n                    },\n                })(payload.type);\n            },\n            [sceneEvents.POST_UPDATE]: (ev) => {\n                dispatchEvent(inputEvents.INPUT_UPDATE_STATE, { payload: _state });\n                // _state.down && dispatchEvent(inputEvents.KEY_DOWN)\n                // _state.up && dispatchEvent(inputEvents.KEY_UP)\n                //\n                _state.preventGlobalPanSingle &&\n                    setTimeout(() => {\n                        _state.preventGlobalPanSingle = false;\n                    });\n                _state.lastPointerPos = (0,es/* clone */.d9v)(scene.input.activePointer.position);\n                if (_state.preventDoubleBufferedSingleTap) {\n                    setTimeout(() => {\n                        // _state.preventDoubleBufferedSingleTap = false\n                    });\n                }\n            },\n            [sceneEvents.POST_UPDATE_THROTTLED]: (ev) => {\n                _state.lastPointerPosThrottled = (0,es/* clone */.d9v)(scene.input.activePointer.position);\n            },\n            [inputEvents.EDGE_SLIDE]: (ev) => {\n                _state.inEdgeSlide = true;\n            },\n            [inputEvents.EDGE_SLIDE_END]: (ev) => {\n                _state.inEdgeSlide = false;\n            },\n            [inputEvents.INPUT_PREVENT_GLOBAL_PAN_SINGLE]: (ev) => {\n                _state.preventGlobalPanSingle = true;\n            },\n        };\n    });\n};\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/global/GameStateSingleton.ts\nlet _gameState = 'before-game';\nconst isInGame = () => _gameState === 'in-game';\nconst isNotInGame = () => _gameState !== 'in-game';\nconst setGameState = (st) => (_gameState = st);\nconst getGameState = () => _gameState;\n\n;// CONCATENATED MODULE: ./src/common/matter.ts\n\n\n\nconst getGlobalTimeScale = (scene) => scene.matter.world.engine.timing.timeScale;\n/** Note: need to have the .gameObject attached when creating the Matter instance */\nconst getBodyBFromCollision = (collPair) => collPair.bodyB.gameObject;\nconst getBodyAFromCollision = (collPair) => collPair.bodyA.gameObject;\n// WORKAROUND:::\n// non-existent off-screen body!\nconst _removeMatterPhaserObj = (matterImage) => {\n    matterImage.displayList && matterImage.removeFromDisplayList();\n    matterImage.removeFromUpdateList();\n    matterImage.destroy();\n    matterImage.scene && matterImage.scene.matter.world.remove(matterImage);\n};\nexposeToWindow({ _removeMatterPhaserObj });\nconst matter_MatterObjActions = {\n    isSafe: (obj) => (0,es/* prop */.vgT)('body', obj),\n    destroy: (matterImage) => {\n        // matterImage.scene && matterImage.scene.matter.world.remove(matterImage)\n        _removeMatterPhaserObj(matterImage);\n    },\n    destroyAll: (matterImages) => {\n        matterImages.forEach((o) => o && _removeMatterPhaserObj(o));\n        // matterImages[0].scene && matterImages[0].scene.matter.world.remove(matterImages)\n    },\n    destroyBody: (body) => (body.gameObject?.scene || ObservableScenes.game.scene).matter.world.remove(body),\n};\nconst ZERO = 0;\nconst createBodyFromPoints = (scene, _points, opts\n// pointCount?: number\n) => {\n    const curve = new Phaser.Curves.Spline(_points);\n    const points = curve.getPoints(defaultTo(_points.length, prop('pointCount')(opts)));\n    // const rawPoints = curve.getPoints(_points.length)\n    // const vertexSets = [rawPoints]\n    // NOTE:ALWAYS use 0 for the x,y of the created body if will attach it to an image!!!\n    //// otherwise - bug\n    const newBody = scene.matter.bodies.fromVertices(ZERO, ZERO, \n    // apply scaling\n    [points.map((p) => multiplyPoint(p, defaultTo(1, opts?.scale)))], {\n        angle: 0,\n        isStatic: true,\n        ...opts?.bodyConfig,\n    });\n    // const newBodyRaw = scene.matter.bodies.fromVertices(ZERO, ZERO, [rawPoints], {\n    //   angle: 0,\n    //   isStatic: true,\n    //   isSensor: true,\n    // })\n    return { newBody, newBodyRaw: null };\n};\nconst matter_getMatterBody = (matterObj) => {\n    return matterObj.body;\n};\nconst _getObjName = (0,es/* either */.wEe)((0,es/* path */.ETc)(['gameObject', 'name']), (0,es/* prop */.vgT)('label'));\n// export const findGameObjectByName = (...args: GameObject[]) => args.map(prop('gameObject') as any).find(propEq('name', OBJECT_NAMES.PARACHUTER))\nconst createBodyFinder = (objNameOrLabel) => (0,es/* compose */.qCK)((0,es/* equals */.fS0)(objNameOrLabel), _getObjName);\nconst findMatterObjectInCollisionEvByNameOrLabel = (objName, ...args) => {\n    const bodyFinder = createBodyFinder(objName);\n    const foundBody = args.find(bodyFinder);\n    return foundBody && foundBody.gameObject;\n};\nexposeToWindow({ findMatterObjectInCollisionEvByNameOrLabel });\nconst getAllMatchingObjectsInCollisionByName = (bodyA, bodyB) => (objectNames) => {\n    return objectNames\n        .map((objName) => findMatterObjectInCollisionEvByNameOrLabel(objName, bodyA, bodyB))\n        .filter(isDefined)\n        .reduce((acc, obj) => {\n        acc[obj.name] = obj;\n        return acc;\n    }, {});\n};\nconst collisionMatchesPair = (bodyA, bodyB, objNames) => {\n    const bodies = [bodyA, bodyB];\n    return ((_getObjName(bodyA) === objNames[0] && _getObjName(bodyB) === objNames[1]) ||\n        (_getObjName(bodyA) === objNames[1] && _getObjName(bodyB) === objNames[0]));\n    return all((name) => any(either(pathEq(['gameObject', 'name'], name), propEq('label', name)))(bodies))(objNames);\n};\nconst hasAnyObjectInCollisionPair = (pair, objectNames) => {\n    const result = getAllMatchingObjectsInCollisionByName(pair.bodyA, pair.bodyB)(objectNames);\n    const hasOtherObject = Object.values(result).find(isDefined);\n    return hasOtherObject;\n};\nconst getMatterObjAngle = (obj) => {\n    if (!path(['body'], obj))\n        return 0;\n    return obj.angle;\n};\n// TODO:REFACTOR -> extract this as a higher-order function: if (!path(['body'], obj)) return 0\nconst getMatterObjSpeed = (obj) => {\n    if (!path(['body'], obj))\n        return 0;\n    const plrPrevPos = obj.body.positionPrev;\n    const objPos = obj.body.position;\n    return Phaser.Math.Distance.BetweenPoints(plrPrevPos, objPos);\n};\nconst getMatterObjAngularVelo = (obj) => {\n    if (!path(['body'], obj))\n        return 0;\n    const angularVelocity = obj.body.angularVelocity;\n    return angularVelocity;\n};\nconst getMatterBodySize = (body) => ({\n    w: body.bounds.max.x - body.bounds.min.x,\n    h: body.bounds.max.y - body.bounds.min.y,\n});\n// TODO:\nconst applyFixedTimeStep = () => {\n    // console.log('preup', ...args)\n    // this._deltaAccum += delta\n    // if (this._deltaAccum > _60_FPS_DELTA) {\n    //   this._deltaAccum -= _60_FPS_DELTA\n    //   dispatchEvent(this.observable, sceneEvents.UPDATE, { time, delta })\n    //   // this.matter.world.step(_60_FPS_DELTA);\n    //   const timeScale = this.matter.world.engine.timing.timeScale\n    //   this.matter.world.enabled && this.matter.world.step(_60_FPS_DELTA * timeScale)\n    // }\n};\nconst applyDeltaTimeStep = () => {\n    // TODO\n};\n\n;// CONCATENATED MODULE: ./src/LD55/events.ts\n\nconst events = (0,dist.constructEvents)([\n    'LD_GAME_START',\n    'LD_GAME_ENDED',\n    'LD_CROSSHAIR_COUNT_REACHED',\n    'LD_SPACEBAR_PULSATE_START',\n    'LD_SPACEBAR_PULSATES',\n    'LD_PLAYER_SUMMON',\n    'LD_PLAYER_SUMMON_ENDED',\n    /** When a minute passes with the timer after game start */\n    'LD_TIMER_MINUTE_PASS',\n    'LD_TIMER_HALF_MINUTE_PASS',\n    /** A trigger for the bug to reproduce */\n    'LD_REPROD_ME',\n    /** A signal that a bug reproduced */\n    'LD_BUG_REPRODUCED',\n    /** A signal to a given crosshair to summon a bug */\n    'LD_SUMMON_BUGS_ON_ME',\n    /** For the total number of bugs to summon along all targets (when Space) */\n    'LD_SUMMON_SET_COUNT',\n    /** For when ending a summoning */\n    'LD_EARTH_DECREASED_HP',\n    /** For when unsummoning */\n    'LD_EARTH_INCREASED_HP',\n    /** When Earth loses HP */\n    'LD_EARTH_HIT',\n    'LD_ENEMY_BUG_KILLED',\n    /** Brings the total number of points as well as the change (count) */\n    'LD_POINTS_CHANGED',\n    /** Unsummoning action */\n    'LD_DO_UNSUMMON',\n    /** Crosshair cleared */\n    'LD_CROSSHAIR_REMOVED',\n    /** Game lost */\n    'LD_GAME_LOST',\n]);\n\n;// CONCATENATED MODULE: ./src/common/image.ts\n\n\nconst createNoTxtImage = ({ scene }) => {\n    const img = scene.matter.add.image(0, 0, TEXTURES_MAP.NO_TEXTURE).setScale(getRelativeScale());\n    return img;\n};\nconst createImage = ({ scene, texture }) => {\n    const img = scene.add.image(0, 0, texture).setScale(screen_getRelativeScale());\n    // .setTint(0xb61d00)\n    // .setData('id', index)\n    // .setInteractive()\n    return img;\n};\nconst createMatterImage = ({ scene, texture }) => {\n    const img = scene.matter.add.image(0, 0, texture).setScale(screen_getRelativeScale());\n    // .setTint(0xb61d00)\n    // .setData('id', index)\n    // .setInteractive()\n    return img;\n};\nconst createStaticSprite = ({ scene, texture, anim, }) => {\n    const spr = scene.add.sprite(0, 0, texture, undefined).setScale(getRelativeScale());\n    anim && spr.play(anim);\n    return spr;\n};\nconst createSprite = ({ scene, texture = textures_TEXTURES_MAP.NO_TEXTURE, bodyConfig, anim, }) => {\n    const spr = scene.matter.add\n        .sprite(0, 0, texture, undefined, bodyConfig)\n        .setScale(screen_getRelativeScale());\n    // const spr = scene.add.sprite(0, 0, texture).setScale(getRelativeScale())\n    anim && spr.play(anim);\n    return spr;\n};\n\n;// CONCATENATED MODULE: ./src/core/createHTMLEvents.ts\n\n\nconst createHTMLEvents = obsDispCreator(({ containerElOrSelector, trackEvents, dispatchTarget } = {}) => {\n    const state = {\n        $: null,\n        eventHandlersByEvent: {},\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            // attach all the events\n            state.$ = getContainerEl(containerElOrSelector || document.body);\n            const $ = state.$;\n            const evNames = trackEvents ? trackEvents : getSupportedEventNames();\n            evNames.forEach((evName) => {\n                state.eventHandlersByEvent[evName] = (...args) => {\n                    const ev = args[0];\n                    const target = args[0].target;\n                    const type = args[0].type;\n                    ///// -> AD-HOC patch\n                    if (type === 'keydown') {\n                        if (target.tagName === 'INPUT') {\n                            return true;\n                        }\n                    }\n                    ///// <-\n                    dispatchEvent(ODHTMLEvents.HTML_EV_ANY, {\n                        // target: dispatchTarget,\n                        payload: { target, type: type, wrappedEventArgs: args },\n                    });\n                };\n                $.addEventListener(evName, state.eventHandlersByEvent[evName]);\n            });\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            Object.keys(state.eventHandlersByEvent).forEach((evName) => state.$.removeEventListener(evName, state.eventHandlersByEvent[evName]));\n        },\n    };\n});\nconst getContainerEl = (containerElOrSelector) => {\n    return typeof containerElOrSelector === 'string'\n        ? document.querySelector(containerElOrSelector)\n        : containerElOrSelector;\n};\n/** Possibly non-exhaustive */\nconst getSupportedEventNames = () => {\n    return [\n        ...new Set([\n            ...Object.getOwnPropertyNames(document),\n            ...Object.getOwnPropertyNames(Object.getPrototypeOf(Object.getPrototypeOf(document))),\n            ...Object.getOwnPropertyNames(Object.getPrototypeOf(window)),\n        ].filter((k) => k.startsWith('on'))),\n    ].map((evName) => evName.slice(2));\n};\nexposeToWindow({ getSupportedEventNames });\nconst ODHTMLEvents = constructEvents(['HTML_EV_ANY']);\n\n// EXTERNAL MODULE: ./node_modules/prando/dist/Prando.es.js\nvar Prando_es = __webpack_require__(405);\n;// CONCATENATED MODULE: ./src/common/prandom.ts\n\nconst getGamePrando = () => new Prando_es/* default */.Z('bugs-vs-bugs');\n// export const getNextRandomIntPos = (outsideOf: Point, dist: number) => {\n//   return {\n//     x: _prand.nextInt((outsideOf.x + dist) * (_prand.nextBoolean() ? 1 : -1)),\n//     y: _prand.nextInt(),\n//   }\n// }\n\n;// CONCATENATED MODULE: ./src/LD55/global/global.ts\n\n\n\n\nconst Global = {\n    earthPos: { x: 0, y: 0 },\n    earthRadius: 100,\n    // core state\n    earthHp: 100,\n    selectedSummonCountDefault: 3,\n    selectedSummonCount: 3, // TODO: use everywhere ! ! !\n    //\n    baseGameZoom: 1,\n    // State flags\n    summonEnded: false,\n    isEvery30thFrame: false,\n    isEvery60thFrame: false,\n    ignoreGlobalPointerDown: false,\n    isUnsummoning: false,\n    //\n    timerS: 0,\n    timerMin: 0,\n    totalKills: 0,\n    totalLostBugs: 0, // TODO:use\n    totalBugsSummoned: 0,\n    //\n    prando: getGamePrando(),\n    playMp3Sound: null,\n};\nexposeToWindow({ Global });\nconst getTotalEnemyCount = () => {\n    return ObservableScenes.game.children.getAll('name', 'bug-enemy').length;\n};\nconst setTempIgnoreGlobalPointerDown = () => {\n    Global.ignoreGlobalPointerDown = true;\n    defer(() => (Global.ignoreGlobalPointerDown = false));\n};\n\n;// CONCATENATED MODULE: ./src/LD55/controlPlayerSummoning.ts\n\n\n\n\n\n\n\n\n\nconst PULSATE_DURATION = 2500;\nconst controlPlayerSummoning = obsDispCreator(() => {\n    const state = {\n        readyToShoot: false,\n        spacebarImg: null,\n        tweenPulsate: null,\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            //\n        },\n        [events.LD_CROSSHAIR_COUNT_REACHED]: () => {\n            if (Global.selectedSummonCount <= 0)\n                return;\n            state.readyToShoot = true;\n            state.spacebarImg = createImage({\n                scene: ObservableScenes.foreground,\n                texture: textures_TEXTURES_MAP.SPACEBAR,\n            })\n                .setX(camera_mainCam(ObservableScenes.game).width / 2)\n                .setY(camera_mainCam(ObservableScenes.game).height - 100);\n            dispatchEvent(events.LD_SPACEBAR_PULSATE_START);\n            state.tweenPulsate = ObservableScenes.game.add.tween({\n                targets: [state.spacebarImg],\n                scale: { from: 1.6, to: 0.5 },\n                ease: types_Easing.Bounce,\n                duration: PULSATE_DURATION,\n                repeat: -1,\n                yoyo: true,\n                onUpdate: () => {\n                    dispatchEvent(events.LD_SPACEBAR_PULSATES, {\n                        payload: { scale: state.spacebarImg.scale },\n                        target: getObserversByName('crosshair'),\n                    });\n                },\n            });\n        },\n        [events.LD_SUMMON_SET_COUNT]: (ev) => {\n            const { count } = ev.payload;\n            Global.selectedSummonCount = count;\n        },\n        [events.LD_PLAYER_SUMMON_ENDED]: () => {\n            Global.earthHp -= Math.max(0, Global.selectedSummonCount);\n            dispatchEvent(events.LD_EARTH_DECREASED_HP);\n            Global.selectedSummonCount = Math.min(Global.selectedSummonCount, Global.earthHp);\n            Global.totalBugsSummoned += Global.selectedSummonCount;\n            state.tweenPulsate?.remove();\n            state.tweenPulsate = null;\n            // remove summon-circle's\n            getObserversByName('summon-circle').forEach((o) => ODAPI.removeObs(o));\n            // Initiate freidnly-bugs summonning for each crosshair\n            const crosshairs = getObserversByName('crosshair');\n            const crosshairNumber = crosshairs.length;\n            const summonPerCrosshair = Math.ceil((Global.selectedSummonCount / crosshairNumber));\n            let bugsLeftToSummon = Global.selectedSummonCount;\n            crosshairs.forEach((cross) => {\n                if (bugsLeftToSummon <= 0)\n                    return;\n                cross.dispatchEvent(events.LD_SUMMON_BUGS_ON_ME, {\n                    payload: { bugCount: Math.min(summonPerCrosshair, bugsLeftToSummon) },\n                    target: cross,\n                });\n                bugsLeftToSummon -= summonPerCrosshair;\n            });\n        },\n        [ODHTMLEvents.HTML_EV_ANY]: ({ payload }) => {\n            const { type, wrappedEventArgs } = payload;\n            // PRESSING SPACE\n            if (state.readyToShoot &&\n                type === 'keydown' &&\n                wrappedEventArgs[0].key === ' ' &&\n                Global.selectedSummonCount > 0) {\n                dispatchEvent(events.LD_PLAYER_SUMMON);\n                state.readyToShoot = false;\n                state.spacebarImg.alpha = 0;\n            }\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            // TODO\n        },\n    };\n}, { id: 'control-player-shooting' });\n\n;// CONCATENATED MODULE: ./src/common/point.ts\nconst point_getObjPos = (obj) => {\n    return {\n        x: obj.x,\n        y: obj.y,\n    };\n};\n\n;// CONCATENATED MODULE: ./src/common/direction.ts\n\nconst velocityToTarget = (from, to, speed = 0.00016) => {\n    if (!from || !to)\n        return { x: 0, y: 0 };\n    const _speed = debug_useDebugConstant('velToTarget_speed', speed);\n    const direction = Math.atan((to.x - from.x) / (to.y - from.y));\n    const speed2 = to.y >= from.y ? _speed : -_speed;\n    return { x: speed2 * Math.sin(direction), y: speed2 * Math.cos(direction) };\n};\n// taken from Phaser3's source\nconst velocityFromAngle = (angle, speed) => {\n    if (speed === undefined) {\n        speed = 60;\n    }\n    const vec2 = new Phaser.Math.Vector2();\n    return vec2.setToPolar(angle * Phaser.Math.DEG_TO_RAD, speed);\n};\nconst angleBetweenPoints = (p1, p2) => {\n    return Phaser.Math.Angle.BetweenPoints(p1, p2) * Phaser.Math.RAD_TO_DEG;\n};\n/** Effectively the same as velocityToTarget (but slower?) */\nconst velocityBetweenAngleFromPoints = (p1, p2, speed) => {\n    return velocityFromAngle(angleBetweenPoints(p1, p2), speed);\n};\nconst getAngleFromVelocity = (vec, subtractDeg = 90) => {\n    const angle = Math.atan2(vec.y, vec.x) + Math.PI / 2;\n    const normalized = (angle > 0 ? angle : Phaser.Math.PI2 + angle) * Phaser.Math.RAD_TO_DEG - subtractDeg;\n    return normalized;\n};\nconst setAngleFromVelocity = (matterImg, veloOverride) => {\n    const velocity = veloOverride || matterImg.body.velocity;\n    const newAngle = getAngleFromVelocity(velocity);\n    matterImg.setAngle(newAngle);\n    return newAngle;\n};\n\n;// CONCATENATED MODULE: ./src/core/matterObj.ts\n\n\n\n\nconst DEFAULT_PHYS_PROPS = {\n    mass: 1,\n    scale: 1,\n    // NORMAL ::: normal defaults\n    friction: 0.2,\n    frictionAir: 0.1,\n    frictionStatic: 0.2,\n    bounce: 0.5,\n    ignoreGravity: false,\n    gravity: 3,\n    timeScale: 1,\n    /** If enemy and If force is to be applied every step */\n    followSpeed: 0.00016,\n    rectangleSize: null,\n    radius: 50,\n};\nconst clampVelocity = (obj, maxVel) => {\n    // this does:\n    // state.crate.body.velocity.x = Math.min(ObjectSpeed.SLOW_X50, state.crate.body.velocity.x)\n    // state.crate.body.velocity.y = Math.min(ObjectSpeed.SLOW_X50, state.crate.body.velocity.y)\n    // doesn't work:\n    const velocity = pathOr(null, ['body', 'velocity'], obj);\n    if (!velocity)\n        return;\n    if (velocity.x > maxVel.x)\n        obj.setVelocityX(maxVel.x);\n    if (velocity.y > maxVel.y)\n        obj.setVelocityX(maxVel.y);\n};\nconst clampAngularVelocity = (obj, maxAbsValue) => {\n    const angVel = path(['angularVelocity'], obj.body);\n    if (Math.abs(angVel) > maxAbsValue) {\n        obj.setAngularVelocity(Math.sign(angVel) * maxAbsValue);\n    }\n};\n/** TODO: instead use PositionGetters.getPosition */\nconst getPositionFromXY = (obj) => defaultTo({ x: -1, y: -1 }, obj.body && pick(['x', 'y'], obj));\nconst getPosition = (0,es/* pathOr */.pMU)({ x: -1, y: -1 }, ['position']);\nconst getBody = (0,es/* path */.ETc)(['body']);\nconst getBodyVelocity = (body) => {\n    const velocity = {\n        x: body.position.x - body.positionPrev.x,\n        y: body.position.y - body.positionPrev.y,\n    };\n    return velocity;\n};\n/**\n * Technically, simply the greatest difference between every point (boundary\n * of the body) - does not need be a circle */\nconst getBodyDiameter = (body) => {\n    const diameter = Math.max(body.bounds.max.x - body.bounds.min.x, body.bounds.max.y - body.bounds.min.y);\n    return diameter;\n};\n/**\n * Does the main camera see the objects?\n * Also returns the removed objects */\nconst destroyIfNotVisibleOnScreen = (gos) => {\n    if (gos.length > 0) {\n        const visibleOnes = mainCam(gos[0].scene).cull(gos);\n        const offScreensGos = gos.filter((b) => b.y > getScreenDprHeight() && !visibleOnes.includes(b));\n        MatterObjActions.destroyAll(offScreensGos);\n        return offScreensGos;\n    }\n    else {\n        return [];\n    }\n};\nconst _getCollBodyLabel = (0,es/* path */.ETc)(['label']);\nconst getCollBodyNames = (collPair) => {\n    return [_getCollBodyLabel(collPair.bodyA), _getCollBodyLabel(collPair.bodyB)];\n};\n\n;// CONCATENATED MODULE: ./src/core/createMttrGameObj.ts\n\n\n\n\n\nconst createMttrGameObj = (opts) => {\n    const physicsProps = (0,es/* mergeDeepRight */.BPw)({ ...DEFAULT_PHYS_PROPS }, opts.physicsProps || {});\n    const pos = opts.pos;\n    const obj = (opts.isSprite ? createSprite : createMatterImage)({\n        scene: opts.scene || ObservableScenes.game,\n        texture: opts.texture,\n    });\n    if (opts.isCircle) {\n        obj.setBody({ type: 'circle', addToWorld: true, radius: physicsProps.radius }, { label: opts.name });\n    }\n    if (physicsProps.rectangleSize) {\n        obj.setBody({ ...physicsProps.rectangleSize });\n    }\n    obj\n        .setName(opts.name)\n        // .setFrictionStatic(physicsProps.friction)\n        .setInteractive()\n        .setMass(1 / physicsProps.gravity) // HIGHER mass - even funnier bouncing\n        // note: very LOW - lunar effect on touch\n        .setAlpha(1)\n        .setScale(screen_getRelativeScale(physicsProps.scale))\n        .setIgnoreGravity(physicsProps.ignoreGravity)\n        .setFrictionAir(physicsProps.frictionAir)\n        .setFrictionStatic(physicsProps.frictionStatic)\n        .setBounce(physicsProps.bounce);\n    // TODO: apply HAGObjectProps.baseProps.hp / rest...\n    obj.body.velocity.x = 0;\n    obj.body.velocity.y = 0;\n    obj.body.gameObject.label = opts.name;\n    obj.body.label = opts.name;\n    obj.body.slop = 1; // this behaves better than the default 0.05? -> it is faster?\n    if (opts.isSprite && opts.anim) {\n        ;\n        obj.play(opts.anim);\n    }\n    if (opts.pos)\n        obj.setPosition(pos.x, pos.y);\n    return obj;\n};\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/const/CollisionsCategory.ts\n\nvar COLLISION_CATEGORY;\n(function (COLLISION_CATEGORY) {\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"NONE\"] = -1] = \"NONE\";\n    /** Enemies can pass through it, but its not Sensor */\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"Player\"] = 1] = \"Player\";\n    /** The Sensor version of Player; For detecting sensor collisions with enemies/projectiles */\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"PlayerSensor\"] = 2] = \"PlayerSensor\";\n    /** Collides with self but not with player / acts as sensor to it */\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"Enemy\"] = 4] = \"Enemy\";\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"Ground\"] = 8] = \"Ground\";\n    // to be ??:\n    // CollidableEnemy = 2 ** 4, // to be?\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"EjectArea\"] = 16] = \"EjectArea\";\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"SelfCollidableSensorEnemy\"] = 32] = \"SelfCollidableSensorEnemy\";\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"PlayerProjectile\"] = 64] = \"PlayerProjectile\";\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"EnemyProjectile\"] = 128] = \"EnemyProjectile\";\n    COLLISION_CATEGORY[COLLISION_CATEGORY[\"Loot\"] = 256] = \"Loot\";\n})(COLLISION_CATEGORY || (COLLISION_CATEGORY = {}));\nexposeToWindow({ COLLISION_CATEGORY });\n\n;// CONCATENATED MODULE: ./src/common/tween.ts\nconst setAdvancedTimeout = ({ scene, duration, tweenConfig, }) => {\n    return new Promise((resolve) => scene.time.delayedCall(duration, resolve)\n    // {\n    //     targets: [],\n    //     alpha: { from: 0, to: 1 }, // arbitrary prop\n    //     duration,\n    //     yoyo: false,\n    //     repeat: 0,\n    //     ...tweenConfig,\n    //     onComplete: (tween) => resolve({ tween }),\n    //   })\n    // )\n    );\n};\n\n;// CONCATENATED MODULE: ./src/LD55/createBugWave.ts\n\n\n\n\n\n\n\n\nconst createBugWave = obsDispCreator((props) => {\n    const c = props.bugWaveConfig;\n    const state = {\n        obs: null,\n        newGenerationBugs: [],\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: dist.ObsDispCreate.useObs(async (obs) => {\n            state.obs = obs;\n            // PERF FIX\n            if (getTotalEnemyCount() > 100)\n                return;\n            const bugs = (0,es/* repeat */.rx1)(null, props.bugWaveConfig.initialCount).map((_, ind) => {\n                return createBugForWave(props.pos, c);\n            });\n            const getExistingBugs = () => getObserversByName('bug');\n            if (c.reprodStartAfterS) {\n                await triggerDivision(c, bugs, () => {\n                    removeObs(obs); // clean itself after this\n                });\n                // await triggerDivision(c, getExistingBugs())\n                // await triggerDivision(c, getExistingBugs())\n                // await triggerDivision(c, getExistingBugs())\n                // await triggerDivision(c, getExistingBugs())\n                // setAdvancedTimeout({\n                //   scene: ObservableScenes.game,\n                //   duration: c.reprodStartAfterS * 1000,\n                // }).then((tween) => {\n                //   // pick % count of bugs\n                //   const countToReprod = parseInt((c.initialCount * (c.populReproductionPct / 100)) as any)\n                //   const reprodBugs = bugs.slice(0, countToReprod)\n                //   dispatchEvent(events.LD_REPROD_ME, { target: reprodBugs, payload: { bugWaveConfig: c } })\n                // })\n            }\n            // TODO:CLEAN remove immediately after?\n        }),\n        [obsDispEvents.OBS_REMOVE]: () => {\n            // <nothing here> ?\n            state.obs = null;\n        },\n    };\n});\nconst createBugForWave = (pos, c) => {\n    const bug = createBug({ pos, type: c.bugSize });\n    return bug;\n};\nconst triggerDivision = (c, bugsToReprod, afterDone) => {\n    return setAdvancedTimeout({\n        scene: ObservableScenes.game,\n        duration: c.reprodStartAfterS * 1000,\n    })\n        .then((tween) => {\n        // pick % count of bugs\n        const countToReprod = parseInt((bugsToReprod.length * (c.populReproductionPct / 100)));\n        const reprodBugs = bugsToReprod.slice(0, countToReprod);\n        dispatchEvent(events.LD_REPROD_ME, { target: reprodBugs, payload: { bugWaveConfig: c } });\n        return reprodBugs;\n    })\n        .then((bugs) => {\n        afterDone?.(bugs);\n        return bugs;\n    });\n};\n\n;// CONCATENATED MODULE: ./src/common/distance.ts\n\n\n\nconst getDistanceToClosestObjFrom = (posFrom, objs) => {\n    let smallestDist = Infinity;\n    let closestObj = null;\n    objs.forEach((o) => {\n        const oPos = pick(['x', 'y'], o || {});\n        const dist = Phaser.Math.Distance.BetweenPoints(oPos, posFrom);\n        if (smallestDist > dist) {\n            smallestDist = dist;\n            closestObj = o;\n        }\n    });\n    return { closestObj, smallestDist };\n};\nconst getDistanceToClosestObjFromCamCenter = (scene, objs) => {\n    const camMiddle = {\n        x: mainCam(scene).scrollX + getScreenDprWidth() / 2,\n        y: mainCam(scene).scrollY + getScreenDprHeight() / 2,\n    };\n    let smallestDist = Infinity;\n    objs.forEach((o) => {\n        const oPos = pick(['x', 'y'], o);\n        const dist = Phaser.Math.Distance.BetweenPoints(oPos, camMiddle);\n        if (smallestDist > dist)\n            smallestDist = dist;\n    });\n    return smallestDist;\n};\n/** Return the closest object of all of the ones matching the label */\nconst findClosestOf = (from, scene, objLabels) => {\n    let closestDist = Infinity;\n    let closestObj = null;\n    scene.children.list.forEach((ch) => {\n        const matchesName = objLabels.includes(ch.name);\n        const chX = ch.x;\n        const chY = ch.y;\n        const hasPos = chX;\n        const isCurrentObj = from.x === chX && from.y === chY;\n        if (!isCurrentObj && matchesName && hasPos) {\n            const distance = Phaser.Math.Distance.Between(from.x, from.y, chX, chY);\n            if (distance < closestDist) {\n                closestDist = distance;\n                closestObj = ch;\n            }\n        }\n    });\n    return closestObj;\n};\n\n;// CONCATENATED MODULE: ./src/LD55/createBug.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst START_HP = 100;\nconst SPEED = 0.5; // 0.5 - default // ##TESTING  2.5 ::\n// import HueRotatePostFX from '../fx/pipelines/pipelines'\nconst createBug = obsDispCreator((props) => {\n    const scene = ObservableScenes.game;\n    const state = {\n        obs: null,\n        bug: null,\n        hp: START_HP, // props.fraction === 'player' ? START_HP * 10 : START_HP, // ##TESTING  ::  START_HP\n        // glowFx: null as Phaser.FX.Glow,\n    };\n    const fraction = (0,es/* defaultTo */.yAE)('enemy', props.fraction);\n    const isEnemyBug = fraction === 'enemy';\n    const isPlayerBug = !isEnemyBug;\n    return {\n        [obsDispEvents.OBS_CREATE]: dist.ObsDispCreate.useObs((obs) => {\n            state.obs = obs;\n            state.bug = createMttrGameObj({\n                scene,\n                texture: getBugTexture(props),\n                name: getBugName(props),\n                isCircle: true,\n                physicsProps: {\n                    radius: getRadius(props),\n                },\n            })\n                .setPosition(props.pos.x, props.pos.y)\n                .setCollisionCategory(COLLISION_CATEGORY.Enemy)\n                .setCollidesWith([\n                COLLISION_CATEGORY.Enemy,\n                COLLISION_CATEGORY.Player,\n                COLLISION_CATEGORY.PlayerProjectile,\n            ])\n                .setOnCollideActive((collision) => {\n                if (!Global.isEvery30thFrame)\n                    return;\n                const bodyNames = getCollBodyNames(collision);\n                if ((isEnemyBug && bodyNames.includes('bug-player')) ||\n                    (isPlayerBug && bodyNames.includes('bug-enemy'))) {\n                    state.hp -= START_HP / 5; // TODO:LATER:CONFIG - current hit power\n                    if (state.hp <= 0) {\n                        ODAPI.removeObs(obs);\n                        isEnemyBug &&\n                            dispatchEvent(events.LD_ENEMY_BUG_KILLED, { payload: { bugProps: props } });\n                    }\n                }\n            });\n            applyEffect(props, state.bug);\n        }),\n        [sceneEvents.UPDATE]: () => {\n            if (!state.bug)\n                return;\n            if (isEnemyBug) {\n                const closestObj = findClosestOf({ x: state.bug.x, y: state.bug.y }, scene, [\n                    'bug-player',\n                    'earth',\n                ]);\n                // const earthIsClosest = true\n                // const playerBugIsClosest = false\n                if (closestObj) {\n                    // // move to Earth\n                    // const earthPos = { x: Global.earthPos.x, y: Global.earthPos.x }\n                    // const velo = velocityToTarget(getObjPos(state.bug), earthPos, SPEED)\n                    const velo = velocityToTarget(getObjPos(state.bug), closestObj, SPEED);\n                    const angle = getAngleFromVelocity(velo);\n                    state.bug.setVelocity(velo.x, velo.y).setAngle(angle);\n                }\n            }\n            else if (isPlayerBug) {\n                ///\n                if (Global.isUnsummoning) {\n                }\n                ///\n                const closestObj = findClosestOf({ x: state.bug.x, y: state.bug.y }, scene, [\n                    'bug-enemy',\n                ]);\n                // const earthIsClosest = true\n                // const playerBugIsClosest = false\n                if (closestObj) {\n                    // // move to Earth\n                    // const earthPos = { x: Global.earthPos.x, y: Global.earthPos.x }\n                    // const velo = velocityToTarget(getObjPos(state.bug), earthPos, SPEED)\n                    const velo = velocityToTarget(getObjPos(state.bug), closestObj, SPEED);\n                    const angle = getAngleFromVelocity(velo);\n                    state.bug.setVelocity(velo.x, velo.y).setAngle(angle);\n                }\n            }\n        },\n        [events.LD_DO_UNSUMMON]: (ev) => {\n            const { x, y } = ev.payload;\n            if (isPlayerBug && Phaser.Math.Distance.Between(state.bug.x, state.bug.y, x, y) < 300) {\n                state.obs && removeObs(state.obs);\n                // RESTORE HP FOR THE BUG REMOVED\n                Global.earthHp += 1;\n                dispatchEvent(events.LD_EARTH_INCREASED_HP);\n            }\n        },\n        [events.LD_REPROD_ME]: (ev) => {\n            if (!state.obs)\n                return;\n            const c = ev.payload.bugWaveConfig;\n            const newGeneration = (0,es/* repeat */.rx1)(null, c.reprodSpawnCount).map(() => {\n                const bug = createBugForWave({ x: state.bug.x, y: state.bug.y }, c);\n                dispatchEvent(events.LD_BUG_REPRODUCED, { payload: { bug } });\n                return bug;\n            });\n            // 2\n            state.obs && removeObs(state.obs);\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            matter_MatterObjActions.destroyAll([state.bug]);\n            state.bug = null;\n            state.obs = null;\n        },\n    };\n}, {\n    name: 'bug',\n});\nconst getBugTexture = (props) => {\n    return basedOn({\n        small: (0,es/* always */.Bxt)(textures_TEXTURES_MAP.BUG_SMALL),\n        big: (0,es/* always */.Bxt)(textures_TEXTURES_MAP.BUG_BIG),\n        large: (0,es/* always */.Bxt)(textures_TEXTURES_MAP.BUG_BIG),\n    })(props.type);\n};\nconst getBugName = (props) => {\n    return basedOn({\n        enemy: () => 'bug-enemy',\n        player: () => 'bug-player',\n    })(defaultFraction(props));\n};\nconst getRadius = (props) => {\n    return basedOn({\n        small: (0,es/* always */.Bxt)(20),\n        big: (0,es/* always */.Bxt)(50),\n        large: (0,es/* always */.Bxt)(100),\n    })(props.type);\n};\nconst defaultFraction = (props) => (0,es/* defaultTo */.yAE)('enemy', props.fraction);\nconst applyEffect = (props, bug) => {\n    return basedOn({\n        enemy: () => bug.setTintFill(0xff0000), // TOO HEAVY : bug.postFX.addGlow(0xff0000, 0.2, 1, false, 0.1, 20),\n        player: () => bug.setTintFill(0x008200),\n    })(defaultFraction(props));\n};\n\n;// CONCATENATED MODULE: ./src/LD55/createFriendlyBug.ts\n\nconst createFrienlyBug = (props) => {\n    return createBug({ ...props, fraction: 'player' });\n};\n\n;// CONCATENATED MODULE: ./src/LD55/createSummoingCircle.ts\n\n\n\n\nconst createSummoningCircle = obsDispCreator(({ pos, radius } = {}) => {\n    const scene = ObservableScenes.game;\n    const state = {\n        // projectile: null as MatterImage,\n        light: null,\n        tweenLife: null,\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            // state.projectile = createMttrGameObj({\n            //   scene,\n            //   name: 'projectile',\n            //   pos,\n            //   texture: TEXTURES_MAP.NO_TEXTURE,\n            // })\n            //   .setBody({ type: 'circle', addToWorld: true, radius }, { label: 'projectile' })\n            //   .setCollisionCategory(COLLISION_CATEGORY.PlayerProjectile)\n            //   .setCollidesWith(COLLISION_CATEGORY.Enemy)\n            //   .setSensor(true)\n            const initialRadius = radius;\n            const scaleFrom = 1.5 + 0.5 * Math.random();\n            state.light = scene.add.pointlight(pos.x, pos.y, 0x0f0f, radius * scaleFrom, 1, 0.5);\n            state.tweenLife?.destroy();\n            state.tweenLife = scene.add.tween({\n                targets: [state.light],\n                radius: { from: 2 * initialRadius, to: 1, step: 0.5 },\n                ease: types_Easing.Elastic.Out,\n                // ease: Easing.Elastic.InOut,\n                duration: 2200, // 1200\n                yoyo: true,\n                onComplete: () => {\n                    // TODO:NOW destr it\n                    state.light && (state.light.alpha = 0);\n                },\n            });\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            matter_MatterObjActions.destroyAll([state.light]);\n            // state.projectile = null\n            state.light = null;\n        },\n    };\n}, { name: 'summon-circle' });\n\n// EXTERNAL MODULE: ./node_modules/obs-disp/dist/func.js\nvar func = __webpack_require__(78);\n;// CONCATENATED MODULE: ./src/LD55/createCrosshair.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst createCrosshair = obsDispCreator(({ pos, tint, ind, initialScale: _initialScale, removeSoonAfter } = { initialScale: 1 }) => {\n    const scene = ObservableScenes.game;\n    const initialScale = _initialScale || 1;\n    const state = {\n        self: null,\n        crosshair: null,\n        pulsatingScale: 1,\n        tweenPulsate: null,\n    };\n    const destroy = () => {\n        removeObs(state.self);\n        // MatterObjActions.destroy(state.crosshair)\n        // state.crosshair = null\n    };\n    const createPulsateTween = () => {\n        state.tweenPulsate?.destroy();\n        state.tweenPulsate = scene.add.tween({\n            targets: [state.crosshair],\n            scale: {\n                from: 1.5 * initialScale + state.pulsatingScale,\n                to: 0.5 * initialScale + state.pulsatingScale,\n            },\n            // onUpdate: (tween) => {\n            //   const scale = tween.getValue()\n            // },\n            ease: types_Easing.Cubic,\n            duration: PULSATE_DURATION,\n            repeat: -1,\n            yoyo: true,\n        });\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: ObsDispCreate.useObs((obs) => {\n            state.self = obs;\n            state.crosshair = ObservableScenes.game.add\n                .image(pos.x, pos.y, textures_TEXTURES_MAP.CROSSHAIR)\n                .setTint(removeSoonAfter ? 0xff0000 : tint || 0x00ff)\n                .setAlpha(0.7)\n                .setAngle(Math.random() * 359);\n            // get angle to 0\n            scene.add.tween({\n                targets: [state.crosshair],\n                angle: { from: state.crosshair.angle, to: 0 },\n                duration: 2000,\n            });\n            // initial scaling tween\n            if (!removeSoonAfter) {\n                scene.add.tween({\n                    targets: [state.crosshair],\n                    scale: { from: 1.1 * initialScale, to: 0.9 * initialScale },\n                    ease: types_Easing.Cubic,\n                    duration: 1500,\n                    repeat: 0,\n                    yoyo: true,\n                    onComplete: () => {\n                        state.crosshair &&\n                            scene.add.tween({\n                                targets: [state.crosshair],\n                                alpha: { from: 1.1, to: 0.5 },\n                                ease: types_Easing.Cubic,\n                                duration: 1500,\n                                repeat: -1,\n                                yoyo: true,\n                            });\n                    },\n                });\n            }\n            else {\n                scene.add.tween({\n                    targets: [state.crosshair],\n                    scale: { from: 1.1 * initialScale, to: 0.9 * initialScale },\n                    ease: types_Easing.Cubic,\n                    duration: 500,\n                    repeat: 0,\n                    yoyo: true,\n                    onComplete: () => {\n                        destroy();\n                        dispatchEvent(events.LD_CROSSHAIR_REMOVED, {\n                            target: getObserversByName('control-crosshair-creation'),\n                        });\n                    },\n                });\n            }\n        }),\n        [events.LD_SPACEBAR_PULSATE_START]: (ev) => {\n            createPulsateTween();\n        },\n        [events.LD_SPACEBAR_PULSATES]: (ev) => {\n            const scale = (0,dist.payloadPropOr)('scale', 1)(ev);\n            state.pulsatingScale = scale;\n        },\n        [events.LD_PLAYER_SUMMON]: () => {\n            createSummoningCircle({\n                pos: point_getObjPos(state.crosshair),\n                radius: state.pulsatingScale * 50,\n            });\n            scene.add.tween({\n                targets: [state.crosshair],\n                scale: { to: 0.5 },\n                alpha: { to: 0.3 },\n                /*\n      \n              scale: { from: 1, to: 0.5 },\n              alpha: { from: 1, to: 0.3 },\n              */\n                ease: types_Easing.Cubic,\n                duration: 1500,\n                repeat: 0,\n                onComplete: () => {\n                    // !Global.summonEnded -> only once\n                    !Global.summonEnded && dispatchEvent(events.LD_PLAYER_SUMMON_ENDED);\n                    Global.summonEnded = true;\n                    (0,func/* defer */.PQ)(() => {\n                        destroy();\n                        Global.summonEnded = false;\n                    });\n                },\n            });\n        },\n        [events.LD_SUMMON_BUGS_ON_ME]: (ev) => {\n            const bugCount = ev.payload.bugCount;\n            const newBugs = (0,es/* repeat */.rx1)(null, bugCount).map(() => createFrienlyBug({ pos, type: 'small' }));\n            // TODO:CONTINUE - friendly bug config?\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            //\n            matter_MatterObjActions.destroyAll([state.crosshair]);\n            state.crosshair = null;\n        },\n    };\n}, { name: 'crosshair' });\n\n;// CONCATENATED MODULE: ./src/LD55/controlCrosshairCreation.ts\n// createCrosshair\n\n\n\n\n\n\nconst getPointerPos = (scene) => ({\n    x: scene.input.activePointer.worldX,\n    y: scene.input.activePointer.worldY,\n});\nconst controlCrosshairCreation = obsDispCreator(() => {\n    const state = {\n        maxCrosshairs: 3,\n        crosshairCount: 0, // TODO: extract out to Global.currentCrosshairCount\n        canSummon: true,\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            //\n        },\n        [inputEvents.GLOBAL_POINTER_DOWN]: async (ev) => {\n            if (Global.ignoreGlobalPointerDown ||\n                Global.isUnsummoning ||\n                Global.selectedSummonCount <= 0)\n                return;\n            const isPrimaryBtnClicked = ev.payload.pointer.button === 0;\n            if (!isPrimaryBtnClicked || state.crosshairCount >= state.maxCrosshairs) {\n                return;\n            }\n            const crosshairInd = state.crosshairCount;\n            createCrosshair({\n                pos: getPointerPos(ObservableScenes.game),\n                tint: 0x00ff + crosshairInd * 30001 * 300 * Math.random(),\n                ind: crosshairInd,\n                removeSoonAfter: !state.canSummon,\n            });\n            state.crosshairCount++;\n            if (state.crosshairCount === state.maxCrosshairs) {\n                dispatchDeferredEvent(events.LD_CROSSHAIR_COUNT_REACHED);\n            }\n        },\n        [events.LD_CROSSHAIR_REMOVED]: (ev) => {\n            state.crosshairCount--;\n        },\n        [events.LD_SUMMON_SET_COUNT]: (ev) => {\n            const { count } = ev.payload;\n            state.canSummon = count > 0;\n        },\n        [events.LD_PLAYER_SUMMON_ENDED]: () => {\n            state.crosshairCount = 0;\n        },\n    };\n}, { name: 'control-crosshair-creation' });\n\n;// CONCATENATED MODULE: ./src/LD55/controlPause.ts\n\n\n\n\n\n\n\n\n\nconst dispatchGamePause = common_throttle(100, () => dispatchEvent(gameEvents.GAME_PAUSE));\nconst dispatchGameResume = common_throttle(100, () => dispatchEvent(gameEvents.GAME_RESUME));\nconst controlPause = () => {\n    const state = {\n        keyPause: false,\n        wasd: [false, false, false, false],\n        canChangePausedState: true,\n        isPaused: false,\n    };\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => {\n            //\n        },\n        [inputEvents.INPUT_UPDATE_STATE]: (ev) => {\n            const keys = payloadProp('keys')(ev);\n            state.keyPause = keys.p;\n            state.wasd = [keys.w, keys.a, keys.s, keys.d];\n        },\n        [sceneEvents.UPDATE]: () => {\n            if (!isInGame())\n                return;\n            if (state.keyPause && isInGame()) {\n                if (!state.canChangePausedState)\n                    return;\n                ///\n                state.canChangePausedState = false;\n                setTimeout(() => (state.canChangePausedState = true), 300);\n                ///\n                state.isPaused ? dispatchGameResume() : dispatchGamePause();\n            }\n            if (!state.isPaused)\n                return;\n        },\n        [gameEvents.GAME_PAUSE]: () => {\n            if (state.isPaused)\n                return;\n            state.isPaused = true;\n            // handle general pausing logic\n            ObservableScenes.game.matter.world.pause();\n            camera_mainCam(ObservableScenes.game).stopFollow();\n            // TODO:FEAT also shold pause any tweens\n            // ObservableScenes.game.scene.pause()\n        },\n        [gameEvents.GAME_RESUME]: () => {\n            if (!state.isPaused)\n                return;\n            state.isPaused = false;\n            // handle general un-pausing logic\n            ObservableScenes.game.matter.world.resume();\n            // ObservableScenes.game.scene.resume()\n        },\n        [obsDispEvents.OBS_REMOVE]: () => { },\n    });\n};\n\n;// CONCATENATED MODULE: ./src/LD55/controlCameraPanZoom.ts\n\n\n\n\n\n\n\n\nconst PAN_SPEED = 15;\nconst controlCameraPanZoom = () => {\n    const scene = ObservableScenes.game;\n    const state = {\n        wasd: [false, false, false, false],\n    };\n    const handleMouseScroll = (pointer, currentlyOver, dx, dy, dz, event) => {\n        //#region Camera zoom on scroll\n        /* ... */ console.log('scrolled', dx, dy, dz);\n        const scrollUp = dy < 0;\n        const curZoom = camera_mainCam(scene).zoom;\n        camera_mainCam(scene).zoomTo(Phaser.Math.Clamp(curZoom + (scrollUp ? 1 : -1) * 0.2, 0.01, 2), 300);\n        //#endregion\n    };\n    const handleMouseBtnClick = ({ button }) => {\n        const isMiddleClicked = button === 1;\n        // console.log('handleMiddleMouseClick', ...args)\n        isMiddleClicked && camera_mainCam(scene).zoomTo(Global.baseGameZoom, 300);\n    };\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => {\n            scene.input.on('wheel', handleMouseScroll);\n            scene.input.on(Phaser.Input.Events.POINTER_DOWN, handleMouseBtnClick);\n        },\n        [inputEvents.INPUT_UPDATE_STATE]: (ev) => {\n            const keys = payloadProp('keys')(ev);\n            state.wasd = [keys.w, keys.a, keys.s, keys.d];\n        },\n        [sceneEvents.UPDATE]: () => {\n            if (!isInGame())\n                return;\n            const zoom = camera_mainCam(scene).zoom;\n            if (state.wasd[0]) {\n                // console.log('HOLDING W')\n                // w\n                camera_mainCam(ObservableScenes.game).scrollY -= PAN_SPEED / zoom;\n            }\n            if (state.wasd[1]) {\n                // a\n                camera_mainCam(ObservableScenes.game).scrollX -= PAN_SPEED / zoom;\n            }\n            if (state.wasd[2]) {\n                // s\n                camera_mainCam(ObservableScenes.game).scrollY += PAN_SPEED / zoom;\n            }\n            if (state.wasd[3]) {\n                // d\n                camera_mainCam(ObservableScenes.game).scrollX += PAN_SPEED / zoom;\n            }\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            // TODO: remove events\n            scene.input.off('wheel', handleMouseScroll);\n            scene.input.off(Phaser.Input.Events.POINTER_DOWN, handleMouseBtnClick);\n        },\n    });\n};\n\n;// CONCATENATED MODULE: ./src/LD55/controlBugCreation.ts\n\n\n\n\n\n\n\n\nconst LEVEL_1_WAVE = {\n    bugSize: 'small',\n    initialCount: 1,\n    populReproductionPct: 0,\n    reprodStartAfterS: 5,\n    reprodSpawnCount: 2,\n};\n/** Enemy bugs */\nconst controlBugCreation = obsDispCreator(() => {\n    const state = {\n        wave: 0,\n        /** The arc to create bugs from */\n        _creationCircles: [],\n        _creationCirclesBg: [],\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            // first WAVE !\n            state._creationCircles = createCreationsCircles();\n            state._creationCirclesBg = createCreationsCirclesBGs();\n            createBugsFor(state.wave, Global.timerMin, state._creationCircles);\n        },\n        [events.LD_TIMER_HALF_MINUTE_PASS]: () => {\n            state.wave += 1;\n            // X - not here, too fast!  bug creation every 30s\n            // createBugsFor(state.wave, Global.timerMin, state._creationCircles)\n        },\n        [events.LD_TIMER_MINUTE_PASS]: (ev) => {\n            const { secondsTotal, minute } = ev.payload;\n            state.wave = 0; // reset for each minute\n            createBugsFor(state.wave, minute, state._creationCircles);\n        },\n        [events.LD_GAME_ENDED]: () => {\n            state.wave = 0;\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            state._creationCircles = [];\n        },\n    };\n}, { id: 'control-bug-creation' });\nconst createBugsFor = (wave, timeMinute, circles) => {\n    // PERF FIX: and difficulty reduction!\n    if (getTotalEnemyCount() > 100)\n        return;\n    if (timeMinute < 1) {\n        if (Global.timerS < 30) {\n            const yOffset = -1000;\n            // just the first time - the hardcoded ones\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 200, y: 200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 800, y: 200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 400, y: -200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1200, y: 200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1800, y: 200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1400, y: -200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1200, y: 200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1800, y: 200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1400, y: -200 + yOffset } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1200, y: 200 + yOffset * 2 } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1800, y: 200 + yOffset * 2 } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1400, y: -200 + yOffset * 2 } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1200, y: 200 + yOffset * 2 } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1800, y: 200 + yOffset * 2 } });\n            createBugWave({ bugWaveConfig: LEVEL_1_WAVE, pos: { x: 1400, y: -200 + yOffset * 2 } });\n        }\n    }\n    else if (timeMinute >= 1 && timeMinute < 2) {\n        // for circles ! ! !\n        const circleIndToCreateFrom = Global.prando.nextInt(2, 4); // circles.length - 1)\n        const circle = circles[circleIndToCreateFrom];\n        const waveCount = 5;\n        (0,es/* repeat */.rx1)(null, waveCount).map(() => {\n            const nextPos = Global.prando.nextArrayItem(circle.getPoints(20));\n            createBugWave({\n                bugWaveConfig: {\n                    bugSize: 'small',\n                    initialCount: 5,\n                    populReproductionPct: 0,\n                    reprodStartAfterS: 5,\n                    reprodSpawnCount: 2,\n                },\n                pos: nextPos,\n            });\n        });\n    }\n    else if (timeMinute >= 2 && timeMinute < 3) {\n        // for circles ! ! !\n        const circleIndToCreateFrom = Global.prando.nextInt(2, 2); // circles.length - 1)\n        const circle = circles[circleIndToCreateFrom];\n        const waveCount = 7;\n        (0,es/* repeat */.rx1)(null, waveCount).map(() => {\n            const nextPos = Global.prando.nextArrayItem(circle.getPoints(20));\n            createBugWave({\n                bugWaveConfig: {\n                    bugSize: 'small',\n                    initialCount: 5,\n                    populReproductionPct: 0,\n                    reprodStartAfterS: 5,\n                    reprodSpawnCount: 2,\n                },\n                pos: nextPos,\n            });\n        });\n    }\n    else if (timeMinute >= 3 && timeMinute < 4) {\n        // for circles ! ! !\n        const circleIndToCreateFrom = Global.prando.nextInt(4, 6); // circles.length - 1)\n        const circle = circles[circleIndToCreateFrom];\n        const waveCount = 10;\n        (0,es/* repeat */.rx1)(null, waveCount).map(() => {\n            const nextPos = Global.prando.nextArrayItem(circle.getPoints(20));\n            createBugWave({\n                bugWaveConfig: {\n                    bugSize: 'small',\n                    initialCount: 10,\n                    populReproductionPct: 0,\n                    reprodStartAfterS: 5,\n                    reprodSpawnCount: 2,\n                },\n                pos: nextPos,\n            });\n        });\n    }\n    else if (timeMinute >= 4 && timeMinute < 5) {\n        // for circles ! ! !\n        const circleIndToCreateFrom = Global.prando.nextInt(4, 6); // circles.length - 1)\n        const circle = circles[circleIndToCreateFrom];\n        const waveCount = 5;\n        (0,es/* repeat */.rx1)(null, waveCount).map(() => {\n            const nextPos = Global.prando.nextArrayItem(circle.getPoints(20));\n            createBugWave({\n                bugWaveConfig: {\n                    bugSize: 'small',\n                    initialCount: 10,\n                    populReproductionPct: 20,\n                    reprodStartAfterS: 5,\n                    reprodSpawnCount: 2,\n                },\n                pos: nextPos,\n            });\n        });\n    }\n    else if (timeMinute >= 5 && timeMinute < 6) {\n        // for circles ! ! !\n        const circleIndToCreateFrom = Global.prando.nextInt(5, 9); // circles.length - 1)\n        const circle = circles[circleIndToCreateFrom];\n        const waveCount = 5;\n        (0,es/* repeat */.rx1)(null, waveCount).map(() => {\n            const nextPos = Global.prando.nextArrayItem(circle.getPoints(20));\n            createBugWave({\n                bugWaveConfig: {\n                    bugSize: 'small',\n                    initialCount: 15,\n                    populReproductionPct: 30,\n                    reprodStartAfterS: 5,\n                    reprodSpawnCount: 2,\n                },\n                pos: nextPos,\n            });\n        });\n    }\n    else if (timeMinute > 6) {\n        // for circles ! ! !\n        const circleIndToCreateFrom = Global.prando.nextInt(5, 6); // circles.length - 1)\n        const circle = circles[circleIndToCreateFrom];\n        const waveCount = 5;\n        (0,es/* repeat */.rx1)(null, waveCount).map(() => {\n            const nextPos = Global.prando.nextArrayItem(circle.getPoints(20));\n            createBugWave({\n                bugWaveConfig: {\n                    bugSize: 'small',\n                    initialCount: 15,\n                    populReproductionPct: 50,\n                    reprodStartAfterS: 5,\n                    reprodSpawnCount: 2,\n                },\n                pos: nextPos,\n            });\n        });\n        const waveCountBig = 2;\n        (0,es/* repeat */.rx1)(null, waveCountBig).map(() => {\n            const nextPos = Global.prando.nextArrayItem(circle.getPoints(20));\n            createBugWave({\n                bugWaveConfig: {\n                    bugSize: 'big',\n                    initialCount: 3,\n                    populReproductionPct: 50,\n                    reprodStartAfterS: 5,\n                    reprodSpawnCount: 2,\n                },\n                pos: nextPos,\n            });\n        });\n    }\n};\nconst INITIAL_ARC_RADIUS = 1000;\nconst createCreationsCircles = () => {\n    const arcs = (0,es/* repeat */.rx1)(null, 10).map((_, ind) => {\n        const radius = (INITIAL_ARC_RADIUS * (ind + 1)) / 2;\n        return new Phaser.Geom.Circle(Global.earthPos.x + INITIAL_ARC_RADIUS * 0.5 + Global.earthRadius * 2, // the offset is needed due to us rendering /2 / see DPR\n        Global.earthPos.y + INITIAL_ARC_RADIUS * 0.5 + Global.earthRadius * 0.5, radius);\n        // For preview only\n        // return ObservableScenes.game.add.circle(\n        //   Global.earthPos.x + INITIAL_ARC_RADIUS * 0.5 + Global.earthRadius * 2, // the offset is needed due to us rendering /2 / see DPR\n        //   Global.earthPos.y + INITIAL_ARC_RADIUS * 0.5 + Global.earthRadius * 0.5,\n        //   radius,\n        //   0x000000,\n        //   0.05\n        // )\n    });\n    return arcs;\n};\nconst createCreationsCirclesBGs = () => {\n    const bgs = (0,es/* repeat */.rx1)(null, 10).map((_, ind) => {\n        // const radius = INITIAL_ARC_RADIUS * (ind + 1)\n        const bg = ObservableScenes.game.add\n            .image(Global.earthPos.x + INITIAL_ARC_RADIUS * 0.5 + Global.earthRadius * 2, // the offset is needed due to us rendering /2 / see DPR\n        Global.earthPos.y + INITIAL_ARC_RADIUS * 0.5 + Global.earthRadius * 0.5, textures_TEXTURES_MAP.CREATION_CIRCLE)\n            .setScale(ind + 1)\n            .setAlpha(0.25)\n            .setName('creation-circle');\n        sendToBack(bg);\n        return bg;\n    });\n    return bgs;\n};\n\n;// CONCATENATED MODULE: ./src/LD55/createEarth.ts\n\n\n\n\n\n\n\n\n\n\n\nconst LOSE_HP_ON_BUG = 1;\nconst createEarth = obsDispCreator(() => {\n    const scene = ObservableScenes.game;\n    const state = {\n        obs: null,\n        earthImg: null,\n        earthImgMttr: null,\n    };\n    const handleEarthHPDecreased = () => {\n        // TODO:continue -> update the HP bar\n        state.earthImg &&\n            scene.add.tween({\n                targets: [state.earthImg],\n                alpha: { from: 1, to: 0.5 },\n                duration: 300,\n                yoyo: true,\n            });\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: ObsDispCreate.useObs((obs) => {\n            state.obs = obs;\n            const RADIUS = 200;\n            const POS = { x: camera_mainCam(scene).width / 2, y: camera_mainCam(scene).height - 200 };\n            state.earthImg = scene.add\n                .image(POS.x, POS.y, textures_TEXTURES_MAP.EARTH, 0x00ff)\n                .setScale((RADIUS / 600) * 2, (RADIUS / 600) * 2);\n            state.obs = obs;\n            state.earthImgMttr = createMttrGameObj({\n                scene,\n                isSprite: true,\n                texture: textures_TEXTURES_MAP.NO_TEXTURE,\n                name: 'earth',\n                isCircle: true,\n                physicsProps: {\n                    radius: RADIUS,\n                    mass: 50,\n                    frictionAir: 1,\n                },\n            })\n                .setPosition(POS.x, POS.y)\n                .setCollisionCategory(COLLISION_CATEGORY.Player)\n                .setCollidesWith([\n                COLLISION_CATEGORY.Enemy,\n                COLLISION_CATEGORY.Player,\n                COLLISION_CATEGORY.PlayerProjectile,\n            ])\n                .setOnCollideActive((collision) => {\n                if (!Global.isEvery30thFrame)\n                    return;\n                const bodyNames = getCollBodyNames(collision);\n                if (bodyNames.includes('bug-enemy')) {\n                    console.log('EARTH LOSING HP');\n                    Global.earthHp -= LOSE_HP_ON_BUG; // TODO:LATER:CONFIG - current hit power of a bug\n                    Global.earthHp = Math.max(0, Global.earthHp);\n                    Global.selectedSummonCount = Math.min(Global.selectedSummonCount, Global.earthHp);\n                    dispatchEvent(events.LD_EARTH_HIT, { payload: { hp: Global.earthHp } });\n                    handleEarthHPDecreased();\n                    // TODO: decrease\n                    if (Global.earthHp <= 0) {\n                        ODAPI.removeObs(obs);\n                        dispatchEvent(events.LD_GAME_LOST);\n                        dispatchEvent(events.LD_GAME_ENDED);\n                    }\n                }\n            });\n        }),\n        [events.LD_EARTH_DECREASED_HP]: (ev) => {\n            // const { hpDecrement } = ev.payload\n            // Global.earthHp -= Math.max(0, hpDecrement)\n        },\n        [events.LD_EARTH_INCREASED_HP]: (ev) => {\n            // const { hpIncrement } = ev.payload\n            // Global.earthHp += hpIncrement\n        },\n        [sceneEvents.UPDATE]: () => {\n            if (!state.earthImgMttr)\n                return;\n            Global.earthPos.x = state.earthImgMttr.x;\n            Global.earthPos.y = state.earthImgMttr.y;\n            state.earthImg.x = state.earthImgMttr.x;\n            state.earthImg.y = state.earthImgMttr.y;\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            matter_MatterObjActions.destroyAll([state.earthImgMttr, state.earthImg]);\n            state.earthImg = null;\n            state.earthImgMttr = null;\n        },\n    };\n}, { name: 'earth' });\n\n;// CONCATENATED MODULE: ./src/common/htmlEl/addText.ts\n\nconst addText = (props = {}) => addHtmlEl({\n    tag: props.tag || 'div',\n    text: props.text || '',\n    doNotAttach: props.doNotAttach,\n    prependTo: props.prependTo,\n    attachTo: props.attachTo,\n    attrs: props.attrs,\n    parent: props.parent,\n    parentAttrs: props.parentAttrs,\n});\n\n;// CONCATENATED MODULE: ./src/common/htmlEl/addHtmlEl.ts\n\n/**\n * Create html elements.. nothing too serious, just improvising :)\n * / probably not production quality\n * */\nconst addHtmlEl = (props = {}) => {\n    let wrapperEl = null;\n    if (props.label || props.parent) {\n        wrapperEl = document.createElement('div');\n        Object.keys(props.parentAttrs).forEach((key, ind) => {\n            wrapperEl.setAttribute(key, props.parentAttrs[key]);\n        });\n        wrapperEl.appendChild(addText({ text: props.label, tag: 'span' }).el);\n    }\n    let el = document.createElement(props.tag || 'div');\n    if (props.text)\n        el.innerHTML = props.text;\n    if (props.value)\n        el.value = props.value;\n    props.onClick && el.addEventListener('click', props.onClick);\n    props.onChange && el.addEventListener('keyup', props.onChange);\n    props.onChange && el.addEventListener('change', props.onChange);\n    wrapperEl && wrapperEl.appendChild(el);\n    const finalEl = wrapperEl || el;\n    !props.doNotAttach && !props.prependTo && (props.attachTo || document.body).appendChild(finalEl);\n    !props.doNotAttach && props.prependTo && props.prependTo.prepend(finalEl);\n    const attrs = props.attrs || {};\n    Object.keys(attrs).forEach((key, ind) => {\n        el.setAttribute(key, attrs[key]);\n    });\n    const result = {\n        wrapperEl,\n        el,\n        remove: () => {\n            wrapperEl && wrapperEl.remove();\n            el.remove();\n        },\n        setHTML: (html) => {\n            el.innerHTML = html;\n            return result;\n        },\n        setText: (text) => {\n            el.textContent = text;\n            return result;\n        },\n        setValue: (val) => {\n            ;\n            el.value = val;\n            return result;\n        },\n        setDisabled: (disabled) => {\n            disabled ? el.setAttribute('disabled', '') : el.removeAttribute('disabled');\n            return result;\n        },\n        then: (cb) => {\n            cb(result);\n            return result;\n        },\n    };\n    return result;\n};\n\n;// CONCATENATED MODULE: ./src/common/htmlEl/dom.ts\n\nconst unfocusElHack = (el) => {\n    el.setAttribute('disabled', 'true');\n    defer(() => el.removeAttribute('disabled'));\n};\n\n;// CONCATENATED MODULE: ./src/LD55/createTimer.ts\n\n\n\n\nconst createTimer = obsDispCreator(() => {\n    const state = {\n        running: false,\n        timerS: 0,\n        timerMin: 6,\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            //\n        },\n        [events.LD_GAME_START]: () => {\n            state.running = true;\n            state.timerS = 0;\n            state.timerMin = 0;\n            Global.timerS = 0;\n            Global.timerMin = 0;\n        },\n        [events.LD_GAME_ENDED]: () => {\n            state.running = false;\n        },\n        [sceneEvents.UPDATE]: () => {\n            if (state.running && Global.isEvery60thFrame) {\n                state.timerS++;\n                Global.timerS = state.timerS;\n                const minutePassed = state.timerS !== 0 && state.timerS % 60 === 0;\n                const halfMinPassed = !minutePassed && state.timerS !== 0 && state.timerS % 30 === 0;\n                if (halfMinPassed) {\n                    dispatchEvent(events.LD_TIMER_HALF_MINUTE_PASS, {\n                        payload: { secondsTotal: state.timerS, minute: state.timerMin },\n                    });\n                }\n                else if (minutePassed) {\n                    state.timerMin++;\n                    Global.timerMin = state.timerMin;\n                    dispatchEvent(events.LD_TIMER_MINUTE_PASS, {\n                        payload: { secondsTotal: state.timerS, minute: state.timerMin },\n                    });\n                }\n            }\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            //\n        },\n    };\n});\nconst renderGameTime = () => {\n    return `${Global.timerMin}:${Global.timerS % 60 < 10 ? '0' + (Global.timerS % 60) : Global.timerS % 60}`;\n};\n\n;// CONCATENATED MODULE: ./src/LD55/createBottomLeftUI.ts\n//\n\n\n\n\n\n\n\n\n\nconst createBottomLeftUI = obsDispCreator(() => {\n    const state = {\n        timerEl: null,\n        pointsEl: null,\n        label: null,\n        hpSummonSlider: null,\n        //\n        points: 0,\n        // selectedHp: Global.selectedSummonCountDefault,\n    };\n    const refreshUiHTML = () => {\n        getSliderEl()?.removeEventListener('input', handleSliderChange);\n        getSliderEl()?.removeEventListener('change', handleSliderChangeEnd);\n        getSliderEl()?.removeEventListener('keydown', handleSliderChangeEnd);\n        // events\n        state.pointsEl?.setHTML(getPointsHTML(state.points));\n        state.hpSummonSlider?.setHTML(getSummonSlliderHTML(Global.selectedSummonCount, Global.earthHp));\n        state.label?.setHTML(getSummonLabelHTML(Global.selectedSummonCount, Global.earthHp));\n        getSliderEl().addEventListener('input', handleSliderChange);\n        getSliderEl().addEventListener('change', handleSliderChangeEnd);\n        getSliderEl().addEventListener('keydown', handleSliderChangeEnd);\n    };\n    const handleSliderChange = (ev) => {\n        const val = Number(ev.target.value);\n        Global.selectedSummonCount = val;\n        dispatchEvent(events.LD_SUMMON_SET_COUNT, { payload: { count: val } });\n        state.label.el.querySelector('label').innerHTML = getLabelText(Global.selectedSummonCount, Global.earthHp);\n    };\n    const handleSliderChangeEnd = (ev) => {\n        // UNFOCUS\n        unfocusElHack(getSliderEl());\n    };\n    const syncSliderMax = () => {\n        getSliderEl().max = `${Global.earthHp}`;\n    };\n    const getUIEl = () => document.querySelector('#ui');\n    const getSliderEl = () => document.querySelector('.hp-summon-slider');\n    return {\n        [obsDispEvents.OBS_CREATE]: async () => {\n            //\n            state.timerEl = addHtmlEl({\n                attachTo: document.querySelector('#ui'),\n            });\n            state.pointsEl = addHtmlEl({\n                attachTo: document.querySelector('#ui'),\n            });\n            state.label = addHtmlEl({\n                attachTo: document.querySelector('#ui'),\n            });\n            state.hpSummonSlider = addHtmlEl({\n                attachTo: document.querySelector('#ui'),\n            });\n            refreshUiHTML();\n            // position fix:\n            // note: recalc width based on canvas width!\n            getUIEl().style.cssText = `\r\n          position: fixed;\r\n          bottom: 1em;\r\n          width: ${getGameCanvas().offsetWidth}px;\r\n          margin-left: 2em;\r\n        `;\n        },\n        [inputEvents.INPUT_SCREEN_RESIZE]: () => {\n            // update position\n            getUIEl().style.width = `${getGameCanvas().offsetWidth}px`;\n        },\n        [events.LD_PLAYER_SUMMON_ENDED]: () => {\n            refreshUiHTML();\n        },\n        [events.LD_EARTH_HIT]: (ev) => {\n            refreshUiHTML();\n        },\n        [events.LD_EARTH_INCREASED_HP]: (ev) => {\n            refreshUiHTML();\n        },\n        [events.LD_POINTS_CHANGED]: (ev) => {\n            const { points } = ev.payload;\n            state.points = points;\n            refreshUiHTML();\n        },\n        [sceneEvents.UPDATE]: (ev) => {\n            state.timerEl?.setHTML(getTimerHTML());\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            //\n        },\n    };\n}, { id: 'spawn-ui ' });\nconst getLabelText = (selectedHp, leftHp) => `<b>Summon bugs:</b> ${selectedHp}, <b>Max / Earth HP</b>: ${leftHp}`;\nconst getSummonLabelHTML = (selectedHp, leftHp) => {\n    return `<label class=\"hp-summon-slider-label bg-1\">\r\n            ${getLabelText(selectedHp, leftHp)}\r\n          </label>`;\n};\nconst getSummonSlliderHTML = (selectedHp = 2, leftHp) => {\n    return `<input tabindex=\"-1\" style=\"width: 300px;\" class=\"hp-summon-slider\" type=\"range\" min=\"1\"\r\n     max=\"${leftHp}\" value=\"${selectedHp}\" step=\"1\" />`;\n};\nconst getPointsInnerHTML = (points) => `<b>Kill Points:</b> ${points}`;\nconst getPointsHTML = (points) => {\n    return `<label class=\"points-label bg-1\">\r\n              ${getPointsInnerHTML(points)}\r\n            </label>`;\n};\nconst getTimerInnerHTML = () => renderGameTime();\nconst getTimerHTML = () => {\n    return `<label class=\"timer-label bg-1\">\r\n              ${getTimerInnerHTML()}\r\n            </label>`;\n};\n\n;// CONCATENATED MODULE: ./src/LD55/controlGlobalFlags.ts\n\n\n\nconst controlGlobalFlags = obsDispCreator(() => {\n    const state = {\n        frameInd: 0,\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            //\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            //\n        },\n        [sceneEvents.UPDATE]: () => {\n            state.frameInd++;\n            Global.isEvery30thFrame = state.frameInd % 30 === 0;\n            Global.isEvery60thFrame = state.frameInd % 60 === 0;\n        },\n    };\n}, { id: 'control-global-flags' });\n\n;// CONCATENATED MODULE: ./src/LD55/controlPoints.ts\n\n\n\n\nconst controlPoints = obsDispCreator(() => {\n    const state = {\n        points: 0,\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            //\n        },\n        [events.LD_ENEMY_BUG_KILLED]: (ev) => {\n            const { bugProps } = ev.payload; // unused\n            const pointsForKill = getPointsForKill(bugProps);\n            state.points++;\n            dispatchEvent(events.LD_POINTS_CHANGED, {\n                payload: { points: state.points, pointsDelta: pointsForKill },\n            });\n            Global.totalKills++;\n        },\n    };\n});\nconst getPointsForKill = (props) => {\n    return basedOn({\n        small: () => 1,\n        big: () => 5,\n        large: () => 10,\n    })(props.type);\n};\n\n;// CONCATENATED MODULE: ./src/common/text.ts\n\n\n\n\nconst DEFAULT_TEXT_STYLE = {\n    fontFamily: '\"VT323\", Verdana, \"Times New Roman\", Tahoma, serif',\n    fontSize: '1.5rem',\n    color: '#ffffff',\n};\nconst isTextSafe = (text) => text && !(0,es/* isEmpty */.xbD)((0,es/* path */.ETc)(['texture', 'frames'])(text));\nconst setTextSafe = (text, str) => isTextSafe(text) ? text.setText(str) : text;\nconst getFontRem = (remVal) => {\n    // DUE TO FONTS COMING BIGGER ON COMP\n    const IS_CHROME_MOBILE_DEBUG = navigator.userAgent.match(/(IS_MOCKED_PHONE)/);\n    const divideBy2 = IS_CHROME_MOBILE_DEBUG;\n    const newVal = divideBy2 ? remVal / 1.35 : remVal;\n    // debugLog(\"VALUE\", newVal, `${newVal}rem`);\n    return `${newVal}rem`;\n};\nconst drawText = ({ scene, coords: _coords, text, config } = {}) => {\n    const coords = (0,es/* defaultTo */.yAE)({ x: 0, y: 0 }, _coords);\n    const txt = scene.add\n        .text(coords.x, coords.y, text, \n    // DEFAULT_TEXT_STYLE\n    (0,es/* mergeDeepRight */.BPw)(DEFAULT_TEXT_STYLE, config || {}))\n        .setInteractive();\n    return txt;\n    // setImmediate(() => txt.destroy())\n};\nsetGlobalVar(drawText);\nconst centerXText = (text, offsetFromCenter = 0) => {\n    if (!isTextSafe(text))\n        return;\n    text.setX(screen_getScreenDprWidth() / 2 - text.width / 2 + offsetFromCenter);\n    return text;\n};\nconst centerYText = (text, offsetFromCenter = 0) => {\n    if (!isTextSafe(text))\n        return;\n    text.setY(getScreenDprHeight() / 2 - text.height / 2 + offsetFromCenter);\n    return text;\n};\nconst centerText = (text, offsetFromCenter = { x: 0, y: 0 }) => {\n    if (!isTextSafe(text))\n        return;\n    text.setX(screen_getScreenDprWidth() / 2 - text.width / 2 + offsetFromCenter.x);\n    text.setY(screen_getScreenDprHeight() / 2 - text.height / 2 + offsetFromCenter.y);\n    return text;\n};\nconst bottomizeText = (text, offsetFromBottom = 0) => {\n    if (!isTextSafe(text))\n        return;\n    text.setY(screen_getScreenDprHeight() - text.height + offsetFromBottom);\n    return text;\n};\nconst hideText = (text, offsetFromBottom = 0) => {\n    if (!isTextSafe(text))\n        return;\n    text.setVisible(false);\n    return text;\n};\nconst showText = (text, offsetFromBottom = 0) => {\n    if (!isTextSafe(text))\n        return;\n    text.setVisible(true);\n    return text;\n};\nconst createCommonText = (scene) => {\n    return centerText(scene.add\n        .text(0, 0, ``)\n        // .setScale(getRelativeScale())\n        .setAlign('center')\n        .setFontFamily('\"VT323\", Verdana, Courier New')\n        .setFontSize('3rem') //getFontRem(2.5))\n        .setColor('#030303')\n        .setShadow(0, 2, '#f3f3f3'));\n};\nconst createInGameUITitleText = (scene) => {\n    return createCommonText(scene)\n        .setFontFamily('Courier New, Verdana')\n        .setFontSize(getFontRem(2))\n        .setFontStyle('bold')\n        .setShadow(0);\n};\nconst createInGameUIText = (scene) => {\n    return (createCommonText(scene)\n        .setFontFamily('\"VT323\", Verdana, Courier New')\n        .setFontSize(getFontRem(2))\n        // .setFontStyle('bold')\n        .setShadow(0)\n        .setShadow(0, 2, '#a0a0a0'));\n};\nconst createCommonTextLight = (scene) => {\n    return centerText(scene.add\n        .text(0, 0, ``)\n        // .setScale(getRelativeScale())\n        .setAlign('center')\n        .setFontFamily('\"VT323\", Verdana, Courier New')\n        .setFontSize(getFontRem(2))\n        .setColor('#030303')\n        .setShadow(0, 2, '#a0a0a0'));\n};\nconst createText = drawText;\nconst createHeaderText = (config) => createText(merge(config, { config: { fontSize: '3rem' } }));\n/////////////////////// UNUESED?\nconst createLabelBtnText = (config) => createText((0,es/* mergeDeepRight */.BPw)(config, { config: { fontSize: '2rem' } })).setFontFamily('\"VT323\", Verdana, Courier New');\nconst createSliderLabelText = (config) => createText(merge(config, { config: { fontSize: '1.3rem', align: 'left' } }));\nconst createDialogContentText = (config) => createText(merge(config, { config: { align: 'left' } }));\nconst configureMainText = (text) => {\n    text.setAlign('center');\n    text.setFontFamily('\"VT323\", Verdana, Arial');\n    text.setStroke('#de77ae', 10).setShadow(2, 2, '#333333', 2, true, true);\n    // text.setFontSize(5)\n    return text;\n};\n\n;// CONCATENATED MODULE: ./src/LD55/controlGameLostDialog.ts\n\n\n\n\n\n\n\nconst controlGameLostDialog = obsDispCreator(() => {\n    const state = {\n        text: null,\n        gameLost: false,\n        // ui: null as IHTMLElWrapper,\n    };\n    return {\n        [obsDispEvents.OBS_CREATE]: () => {\n            //\n        },\n        [events.LD_GAME_START]: () => {\n            state.text?.destroy();\n            state.gameLost = false;\n        },\n        [events.LD_GAME_LOST]: () => {\n            state.gameLost = true;\n            state.text =\n                state.text ||\n                    centerText(ObservableScenes.foreground.add\n                        .text(0, 0, `\r\nYou survived ${renderGameTime()} minutes!\\n\r\nTotal killed bugs: ${Global.totalKills}\\n\r\nTotal bugs summoned: ${Global.totalBugsSummoned}\\n\r\n\\n\r\nPress R to restart the game\r\n              `, {\n                        padding: {\n                            left: 20,\n                            right: 20,\n                            top: 20,\n                            bottom: 20,\n                        },\n                    })\n                        .setBackgroundColor('#000')\n                        .setFontSize('3em'));\n        },\n        [ODHTMLEvents.HTML_EV_ANY]: ({ payload }) => {\n            const { type, wrappedEventArgs } = payload;\n            // PRESSING SPACE\n            if (state.gameLost && type === 'keydown' && wrappedEventArgs[0].key === 'r') {\n                console.log('restart!');\n                window.location.reload(); // hardcore workaround for now\n                // RECREATE THE ENTIRE GAME\n                // ODAPI.removeAllObservers('ld-55-game')\n                // defer(() => createLD55Game())\n            }\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            //\n        },\n    };\n}, { id: 'control-game-lost' });\n\n;// CONCATENATED MODULE: ./src/LD55/controlBottomActions.ts\n\n\n\n\n\n\n\n\n\nconst controlBottomActions = obsDispCreator(() => {\n    const state = {\n        container: null,\n        bonusUnsummonBtn: null,\n        // Unsummon action:\n        unsummonOverlay: null,\n        isUnsummoning: false,\n    };\n    const scene = ObservableScenes.game;\n    return {\n        [obsDispEvents.OBS_CREATE]: async () => {\n            //\n            state.container = ObservableScenes.foreground.add.container();\n            await waitMs();\n            state.container.add([\n                ObservableScenes.foreground.add.image(0, 0, textures_TEXTURES_MAP.BTN_BASE).setScale(0.5),\n                (state.bonusUnsummonBtn = ObservableScenes.foreground.add.image(0, 0, textures_TEXTURES_MAP.BTN_UNSUMMON)).setScale(0.4),\n            ]);\n            state.bonusUnsummonBtn.setInteractive().on('pointerdown', () => {\n                setTempIgnoreGlobalPointerDown();\n                // dispatchEvent(events.LD_IS_UNSUMMONING)\n                Global.isUnsummoning = true;\n                state.isUnsummoning = true;\n                state.unsummonOverlay = state.unsummonOverlay || switchUnsummonOn();\n                state.unsummonOverlay.alpha = 1;\n            });\n            // position\n            centerXText(state.container);\n            bottomizeText(state.container);\n        },\n        [inputEvents.GLOBAL_POINTER_DOWN]: () => {\n            if (state.isUnsummoning) {\n                console.log('ALL TOUCHING ITEMS - SUMMON BACK ! ;     HP INCR / change');\n                dispatchEvent(events.LD_DO_UNSUMMON, {\n                    payload: { x: scene.input.activePointer.worldX, y: scene.input.activePointer.worldY },\n                });\n                state.unsummonOverlay.alpha = 0;\n                state.isUnsummoning = false;\n                Global.isUnsummoning = false;\n            }\n        },\n        [sceneEvents.UPDATE]: () => {\n            if (state.isUnsummoning && state.unsummonOverlay) {\n                state.unsummonOverlay.x = scene.input.activePointer.worldX;\n                state.unsummonOverlay.y = scene.input.activePointer.worldY;\n            }\n        },\n        // [events.any]: (ev) => {\n        //   // const { points, pointsDelta } = ev.payload\n        //   // state.points += pointsDelta\n        //   // TODO:CONTinue\n        //   // - add the 3 buttons,\n        //   // - make them show createBonusAction() if player has enough points!\n        //   // -- show the bonus overlay! / -- when it's active ->\n        //   // ---- CLICK to apply it! -- createUnsummon, createDecoy, createShockwave,\n        //   // ---- ESCAPE\n        // },\n    };\n});\nconst switchUnsummonOn = () => {\n    const overlay = createUnsummonOverlay();\n    return overlay;\n};\nconst createUnsummonOverlay = () => ObservableScenes.game.add.circle(0, 0, 300, 0xffff00, 0.5).setInteractive();\n// const getPointsForKill = (props: Parameters<typeof createBug>[0]) => {\n//   return basedOn({\n//     small: () => 1,\n//     big: () => 5,\n//     large: () => 10,\n//   })(props.type) as any as number\n// }\n\n;// CONCATENATED MODULE: ./src/LD55/createLD55Game.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// only initial entry point actions dispatched!\nconst createLD55Game = () => {\n    return addObsDisp({\n        [dist.obsDispEvents.OBS_CREATE]: ({ payload: { obs } }) => {\n            // TODO:LATER:LD:CONTINUE later - sth else - for now - direct start\n            setGameState('in-game');\n            // Core:\n            createEarth();\n            createTimer();\n            controlCrosshairCreation();\n            controlPlayerSummoning();\n            controlBugCreation();\n            controlBottomActions();\n            controlGameLostDialog();\n            // Points & bonuses\n            controlPoints();\n            // UI:\n            createBottomLeftUI();\n            // MISC:\n            controlGlobalFlags();\n            controlCameraPanZoom();\n            controlPause();\n            // Start game\n            dispatchDeferredEvent(events.LD_GAME_START);\n        },\n        [events.LD_GAME_START]: () => {\n            // reset\n            Global.earthHp = 100;\n        },\n        [dist.obsDispEvents.OBS_REMOVE]: () => {\n            // GlobalObservers.removeMultipleObs(observers)\n            // _state.keySpace?.destroy()\n            // _state.keySpace = null\n        },\n    }, { id: 'ld-55-game' });\n};\nexposeToWindow({ createLD55Game });\n\n;// CONCATENATED MODULE: ./src/LD55/createBackground.ts\n\n\n\n\n\n\n\n/** Sky gradient + clouds image */\nconst createBackground = (config) => {\n    const observers = [];\n    const scene = ObservableScenes.game;\n    const state = {\n        cloudsBgImg: null,\n        skyBgGradientImg: null,\n    };\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => { },\n        [gameEvents.GAME_START]: () => {\n            // state.skyBgGradientImg = createImage({ scene, texture: TEXTURES_MAP.SKY_BACKGROUND })\n            // state.skyBgGradientImg.scaleX = 4000\n            // state.skyBgGradientImg.scaleY = 4\n            // state.cloudsBgImg = createImage({ scene, texture: TEXTURES_MAP.CLOUDS }).setPosition(\n            //   Plane.initialPos.x,\n            //   Plane.initialPos.y\n            // )\n            // state.cloudsBgImg.setScale(20)\n            // exposeToWindow({ state })\n        },\n        [sceneEvents.UPDATE]: () => {\n            // if (_state.keySpace && scene.input.keyboard.checkDown(_state.keySpace, 500)) {\n            //   _state.isPaused = !_state.isPaused\n            //   _state.isPaused ? GameFlow.pauseGame() : GameFlow.resumeGame()\n            //   debugLog('PAUSED')\n            // }\n        },\n        [events.LD_TIMER_MINUTE_PASS]: () => {\n            // create effect on the background\n            const circles = ObservableScenes.game.children.list.filter((o) => o.name === 'creation-circle');\n            const currentAlpha = circles[0].alpha;\n            ObservableScenes.game.children.list\n                .filter((o) => o.name === 'creation-circle')\n                .forEach((circ) => {\n                scene.add.tween({\n                    targets: [circ],\n                    alpha: { from: circ.alpha, to: 0.5 },\n                    scale: { from: circ.scale, to: circ.scale / 3 },\n                    ease: types_Easing.Circular.InOut,\n                    yoyo: true,\n                });\n            });\n        },\n        GAME_RESTART: () => {\n            matter_MatterObjActions.destroyAll([state.cloudsBgImg, state.skyBgGradientImg]);\n            (state.cloudsBgImg = null), (state.skyBgGradientImg = null);\n        },\n        GAME_WON: () => {\n            matter_MatterObjActions.destroyAll([state.cloudsBgImg, state.skyBgGradientImg]);\n            (state.cloudsBgImg = null), (state.skyBgGradientImg = null);\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            // GlobalObservers.removeMultipleObs(observers)\n            // _state.keySpace?.destroy()\n            // _state.keySpace = null\n        },\n    });\n};\n\n;// CONCATENATED MODULE: ./src/core/createCamera.ts\n\n\n\n\n\n\n\n/** Adjusts automatically the base zoom value based on the number of pixels */\nconst setBaseGameZoom = () => {\n    // SET BASE ZOOM :::\n    const cam = camera_mainCam(ObservableScenes.game);\n    const camSceneBackground = camera_mainCam(ObservableScenes.background);\n    const camSceneForeground = camera_mainCam(ObservableScenes.foreground);\n    // calculate base zoom...\n    let zoom = 1;\n    const fourMillionPixels = 4e6;\n    while ((cam.displayWidth * cam.displayHeight) / zoom < fourMillionPixels) {\n        zoom = zoom - 0.01;\n        cam.setZoom(zoom);\n    }\n    return zoom;\n    // camSceneBackground.zoom = zoom\n    // camSceneForeground.zoom = zoom\n};\nconst setBaseForegroundSceneZoom = () => {\n    // SET BASE ZOOM :::\n    const cam = camera_mainCam(ObservableScenes.foreground);\n    const screenW = screen_getScreenDprWidth();\n    if (screen_getScreenDprWidth() < 1920) {\n        const zoomRatio = (screenW * 1.2) / 1920;\n        cam && cam.setZoom(zoomRatio);\n    }\n};\nconst createCamera = () => {\n    const scene = ObservableScenes.game;\n    const state = {\n        baseGameZoom: -1,\n    };\n    return addObsDisp({\n        [dist.obsDispEvents.OBS_CREATE]: ({ payload: {} }) => {\n            state.baseGameZoom = setBaseGameZoom();\n            Global.baseGameZoom = state.baseGameZoom;\n            setTimeout(() => setBaseForegroundSceneZoom(), 100);\n        },\n        [gameEvents.GAME_PAUSE]: () => {\n            camera_mainCam(scene).setZoom(0.1); // TODO:REMOVE?\n        },\n        [gameEvents.GAME_RESUME]: () => {\n            camera_mainCam(scene).setZoom(state.baseGameZoom);\n        },\n        [gameEvents.GAME_START]: () => { },\n        [gameEvents.GAME_END]: () => { },\n        [dist.obsDispEvents.OBS_REMOVE]: () => {\n            camera_mainCam(scene).stopFollow();\n        },\n    });\n};\n\n// EXTERNAL MODULE: ./node_modules/howler/dist/howler.js\nvar howler = __webpack_require__(766);\n;// CONCATENATED MODULE: ./src/common/createSoundFX.ts\n\n\n\n\nconst createSoundFX = obsDispCreator(() => {\n    const state = {\n        muted: false,\n        mp3SoundPaths: { main: '/music/cosmic-wow.mp3' },\n        mp3Sounds: { levelPass: null },\n    };\n    // const playSoundFX = (s: Parameters<typeof playSound>[0]) => (_: IEvent) =>\n    //   !state.muted && playSound(s)\n    const playMp3Sound = (snd, opts) => {\n        if (state.muted)\n            return;\n        if (!state.mp3Sounds[snd]) {\n            // load it / create it\n            state.mp3Sounds[snd] = new howler.Howl({\n                src: state.mp3SoundPaths[snd],\n                ...opts,\n            });\n        }\n        state.mp3Sounds[snd].play();\n        return state.mp3Sounds[snd];\n    };\n    Global.playMp3Sound = playMp3Sound;\n    return {\n        [obsDispEvents.OBS_CREATE]: ObsDispCreate.useObs((obs) => {\n            let repeatInd = 0;\n            const rates = [1, 0.8, 0.9, 0.75, 1, 0.5];\n            const snd = playMp3Sound('main', {\n                loop: true,\n                onend: () => {\n                    repeatInd = (repeatInd + 1) % rates.length === 0 ? 0 : repeatInd + 1;\n                    snd.rate(rates[repeatInd] || 1);\n                },\n            });\n            exposeToWindow({ snd });\n        }),\n        // SOUND_TOGGLE: () => (state.muted = !state.muted),\n        // PORTAL_ENTERED: playSoundFX('portalEntered'),\n        // LEVEL_REQUEST_START_NEXT: () => playMp3Sound('levelPass'),\n        // LEVEL_STARTED: playSoundFX('startLevel'),\n        // PLAYER_REPOSITION: playSoundFX('playerStep'),\n        // FOE_HIT_BY_PLAYER: playSoundFX('explosion2'),\n        // PLAYER_HIT_BY_FOE: playSoundFX('explosion'),\n        // FRUIT_COLLECTED: playSoundFX('collect2'),\n        // PLAYER_ACTION_ATTACK: playSoundFX('actionAttack'),\n        // LEVEL6_THIRD_EYE_TAKEN: playSoundFX('collect'),\n        // LEVEL5_GAME_RESET_FULL: playSoundFX('funnyGhost'),\n        // LEVEL5_GAME_WON: playSoundFX('diamondPickup'),\n        // GAME_WON: playSoundFX('diamondPickup'),\n        [obsDispEvents.OBS_REMOVE]: () => {\n            Object.values(state.mp3Sounds).forEach((s) => s?.unload());\n        },\n    };\n}, { id: 'sound-fx' });\n\n;// CONCATENATED MODULE: ./src/LD55/GameScene.ts\n\n\n\n\n\n\n\n\n\n\n\nlet gameSceneObservers = [];\nlet recreateObservers = null;\nexposeToWindow({\n    resetGame: () => {\n        gameSceneObservers.forEach((o) => removeObs(o));\n        gameSceneObservers = [];\n        defer(() => recreateObservers(), 100);\n    },\n});\nconst Game = createObservableScene({\n    key: 'GAME_SCENE',\n    createObservers: (scene) => {\n        recreateObservers = () => [\n            initInputDispatcherObserver()(scene),\n            initConfigWorld(scene),\n            createBackground(),\n            createLD55Game(),\n            // createCrate(),\n            // createLevel(),\n            // // misc\n            // createDetectGameWin(),\n            // createDetectGameLose(),\n            // createScreenSwitcher(),\n            // createScreenBeforeGame(),\n            // createExit(),\n            // // createPause(), // in FOREGROUND\n            // core\n            createHTMLEvents({}),\n            createSoundFX(),\n            // ?\n            createCamera(),\n            // createPlane(),\n        ];\n        // console.log('recreateObservers')\n        // if (gameSceneObservers.length === 0)\n        gameSceneObservers = recreateObservers();\n        return gameSceneObservers;\n    },\n    // onPreload: (scene) => {\n    // },\n    onPreload: (scene) => {\n        // scene.input.setDefaultCursor('url(' + cursorsB64.inMenu + '), pointer')\n        // scene.load.setBaseURL('http://localhost:3031')\n        /////// FAILING NOW, WHY ?\n        // scene.load.setBaseURL('http://labs.phaser.io')\n        // scene.load.image(TEXTURES_MAP.BIRD_SPAWNER_1, 'assets/skies/space3.png'\n        // scene.load.image({\n        //   key: TEXTURES_MAP.BIRD_SPAWNER_1,\n        //   url: '/assets/bird/bird-spawner1.png',\n        // })\n    },\n    onCreate: (scene) => { },\n});\n/* harmony default export */ const GameScene = (Game);\n\n;// CONCATENATED MODULE: ./src/scenes/BootScene.ts\n\n\n\n\n\n\n\n\n\n//////// AUDIO\n// import b64SoundTrackLvlIntro from '../../assets/sound/2022.02.13-21.28.32-PM-8-4-lvlIntro.mp3'\n// import b64SoundTrackLvlTheme1 from '../../assets/sound/2022.02.13-21.31.12-PM-8-1-lvlTheme.mp3'\n\n\n\n\n\n/** Use to load assets (and to start the actual game and other scenes) */\nconst BootScene = new Phaser.Class({\n    Extends: Phaser.Scene,\n    initialize: function BootScene() {\n        Phaser.Scene.call(this, { key: BOOT_SCENE_KEY, active: true });\n    },\n    preload: async function () {\n        const scene = this;\n        scene.load.image(textures_TEXTURES_MAP.CROSSHAIR, crosshair_6_namespaceObject);\n        scene.load.image(textures_TEXTURES_MAP.SPACEBAR, spacebar_namespaceObject);\n        scene.load.image(textures_TEXTURES_MAP.BUG_BIG, space_bug_namespaceObject);\n        scene.load.image(textures_TEXTURES_MAP.BUG_SMALL, bug_small_sm_namespaceObject);\n        scene.load.image(textures_TEXTURES_MAP.CREATION_CIRCLE, spawn_circle_namespaceObject);\n        scene.load.image(textures_TEXTURES_MAP.EARTH, earth_sm_namespaceObject);\n        scene.load.image(textures_TEXTURES_MAP.BTN_UNSUMMON, bonus_unsummon_sm_namespaceObject);\n        scene.load.image(textures_TEXTURES_MAP.BTN_BASE, bonus_button_namespaceObject);\n        // scene.load.image(TEXTURES_MAP.PLANE, planeImg)\n        // scene.load.image(TEXTURES_MAP.SKY_BACKGROUND, skyBgImg)\n        // scene.load.image(TEXTURES_MAP.CLOUDS, cloudsImg)\n        // scene.load.image(TEXTURES_MAP.CRATE, crateImg)\n        // scene.load.image(TEXTURES_MAP.FLAG, flagImg)\n        // scene.load.image(TEXTURES_MAP.GROUND1, ground1Img)\n        // scene.load.image(TEXTURES_MAP.GROUND2, ground2Img)\n        // scene.load.image(TEXTURES_MAP.EJECT_AREA, ejectAreaImg)\n        scene.load.image(textures_TEXTURES_MAP.NO_TEXTURE, no_texture_namespaceObject);\n    },\n    // AFTER EVERYTHING HAS PRELOADED :::\n    create: async function () {\n        ////// START SCENES + some wiring\n        const sceneBackground = startScene(this.game, scene_SCENE_KEY.BACKGROUND_SCENE);\n        const sceneForeground = startScene(this.game, scene_SCENE_KEY.FOREGROUND_SCENE);\n        // sceneBackgroundScroller.scene.bringToTop('BackgroundScene')\n        // const sceneStarGravityGame = startScene(this.game, 'STAR_GRAVITY_GAME')\n        exposeToWindow({\n            sceneBackground,\n            sceneForeground,\n        });\n        /// ADD THE GAME SCENE\n        const GAME_SCENE_KEY = scene_SCENE_KEY.GAME_SCENE;\n        const SCENE_CLASS = GameScene;\n        // adds and starts the game\n        this.game.scene.add(GAME_SCENE_KEY, SCENE_CLASS, true, {});\n    },\n});\n\n;// CONCATENATED MODULE: ./src/scenes/BackgroundScene.ts\n\nconst BackgroundScene = createObservableScene({\n    key: 'BACKGROUND_SCENE',\n    createObservers: (scene) => [\n    // initBackgroundSetter(scene),\n    ],\n});\n/* harmony default export */ const scenes_BackgroundScene = (BackgroundScene);\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/createInGameUI.ts\n\n\n\n\n\n\n\n\n\nconst HELP_TEXT = `- W/S - or arrows UP/DOWN to steer plane up/down\\n\r\n- SPACE - for plane high gear ;)\\n\r\n- E - to eject the crate (inside green areas) ;)\\n\r\n- P - to pause/unpause + WASD or arrows to investigate map\r\n- R - to restart a level\r\n- X - to exit from a level\r\nGoal - land the crate near a \\nflag for at least 3 seconds\\n\r\nTip 0: pause a level\\n with P to pan around and see the area\r\nTip 1: ejecting the crate\\nat different speed causes a different\\n direction and velocity\r\nTip 2: speeding the plane makes the ejection different\\n\r\nTip 3: don't crash the plane! \\n`;\nconst createInGameUI = (config) => {\n    const scene = ObservableScenes.foreground;\n    const state = {\n        f1Btn: null,\n        keyF1: false,\n        canKeyF1: true,\n        howToPlayText: null,\n    };\n    const toggleHowToPlayText = () => {\n        state.howToPlayText =\n            state.howToPlayText ||\n                centerText(createLabelBtnText({\n                    scene,\n                    text: HELP_TEXT,\n                    config: { fontSize: '2rem' },\n                }));\n        state.howToPlayText.setText(HELP_TEXT).setVisible(!state.howToPlayText.visible);\n    };\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => {\n            // todo? child observers?\n        },\n        [gameEvents.GAME_START]: () => {\n            /////////// SELECTED LVL NAME DIsPLAYED\n            if (!state.f1Btn) {\n                state.f1Btn = createLabelBtnText({\n                    scene,\n                    coords: { x: 150, y: 400 },\n                    text: `F1`,\n                    config: { fontSize: '5rem' },\n                })\n                    .setPosition(getTopRight(ObservableScenes.foreground, { x: -15, y: -15 }).x, getTopRight(ObservableScenes.foreground, { x: -15, y: -15 }).y)\n                    .on('pointerdown', () => {\n                    toggleHowToPlayText();\n                });\n            }\n            state.howToPlayText?.setVisible(true);\n        },\n        [gameEvents.SCREEN_GO_TO_BEFORE_GAME]: () => {\n            state.howToPlayText?.setVisible(false);\n        },\n        [inputEvents.INPUT_UPDATE_STATE]: (ev) => {\n            const keys = payloadProp('keys')(ev);\n            state.keyF1 = keys.F1;\n        },\n        [sceneEvents.UPDATE]: () => {\n            if (state.keyF1 && state.canKeyF1 && isInGame()) {\n                toggleHowToPlayText();\n                state.canKeyF1 = false;\n                setTimeout(() => (state.canKeyF1 = true), 300);\n            }\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            // GlobalObservers.removeMultipleObs(observers)\n            // _state.keySpace?.destroy()\n            // _state.keySpace = null\n        },\n    });\n};\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/levels/levels.ts\n\nconst GROUND_W = 1100;\nconst GROUND_H = 300;\nconst lvl3Stairs = {\n    name: \"The 3rd Maybe? It's like stairs!\",\n    ejectAreas: [\n        {\n            x: -500,\n            y: -500,\n            w: 1500,\n            h: 1500,\n        },\n        {\n            x: 200,\n            y: 200,\n            w: 1500,\n            h: 1500,\n        },\n    ],\n    ground: [\n        {\n            pos: {\n                // relativeToWater: true, - by default\n                x: -GROUND_W * 2 - 500,\n                y: -GROUND_H * 5,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: false,\n        },\n        {\n            pos: {\n                // relativeToWater: true,\n                x: -GROUND_W - 550,\n                y: -GROUND_H * 4,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: true,\n        },\n        {\n            pos: {\n                // relativeToWater: true,\n                x: 200,\n                y: -GROUND_H * 3,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: false,\n        },\n        {\n            pos: {\n                // relativeToWater: true,\n                x: GROUND_W + 550,\n                y: -GROUND_H * 2,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: true,\n        },\n        {\n            pos: {\n                // relativeToWater: true,\n                x: GROUND_W * 2 + 550,\n                y: -GROUND_H * 1,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: false,\n        },\n        {\n            pos: {\n                // relativeToWater: true,\n                x: GROUND_W * 3 + 550,\n                y: -GROUND_H,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: false,\n        },\n        {\n            pos: {\n                // relativeToWater: true,\n                x: GROUND_W * 4 + 550,\n                y: 0,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: true,\n        },\n        {\n            pos: {\n                // relativeToWater: true,\n                x: GROUND_W * 5 + 550,\n                y: GROUND_H,\n            },\n            texture: textures_TEXTURES_MAP.GROUND1,\n            withFlag: false,\n        },\n    ],\n};\nconst lvl4TinyStairs = {\n    ...lvl3Stairs,\n    ejectAreas: [\n        {\n            x: -500 - 2000,\n            y: -500 + 3000,\n            w: 1000,\n            h: 1000,\n        },\n        {\n            x: 200 - 2000,\n            y: 200 + 3000,\n            w: 1000,\n            h: 1000,\n        },\n    ],\n    name: 'Tiny Stairs.. OOPS!',\n    ground: lvl3Stairs.ground.map((g) => ({\n        ...g,\n        texture: textures_TEXTURES_MAP.GROUND2,\n    })),\n};\nconst _ejectAreasLvl1 = [\n    {\n        x: -1500 * 3,\n        y: +1500 * 3,\n        w: 1500,\n        h: 1500,\n    },\n    {\n        x: -1500 * 2,\n        y: +1500 * 2,\n        w: 1500,\n        h: 1500,\n    },\n    {\n        x: -1500 * 2,\n        y: +1500,\n        w: 1500,\n        h: 1500,\n    },\n    {\n        x: 200,\n        y: 200,\n        w: 1500,\n        h: 1500,\n    },\n    {\n        x: 200 + 1500,\n        y: 200 + 1500,\n        w: 1500,\n        h: 1500,\n    },\n];\nconst LEVEL_EDITOR_INDEX = -1;\nconst LevelEditor = {\n    ground: [],\n    ejectAreas: [],\n    name: 'Level Editor',\n};\nconst Levels = [\n    {\n        name: 'The First One - should be easy',\n        isFromEditor: false,\n        ejectAreas: _ejectAreasLvl1,\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true, - by default\n                    x: -GROUND_W * 2 - 500,\n                    y: 0,\n                },\n                angle: 0,\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: -GROUND_W - 550,\n                    y: 0,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: -200,\n                    y: 0,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 500,\n                    y: 0,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 2 + 550,\n                    y: 0,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 3 + 550,\n                    y: 0,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 4 + 550,\n                    y: 0,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 5 + 550,\n                    y: 0,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n        ],\n    },\n    // 2\n    {\n        name: 'The Second One',\n        ejectAreas: [\n            {\n                x: 200,\n                y: 200,\n                w: 1500,\n                h: 1500,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 4 + 550,\n                    y: -1000,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 5 + 550,\n                    y: -1000,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n        ],\n    },\n    lvl3Stairs,\n    lvl4TinyStairs,\n    {\n        name: 'The High Pot...',\n        ejectAreas: [\n            {\n                x: 200 - 2500,\n                y: 200 - 500,\n                w: 2000,\n                h: 2000,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W - 600,\n                    y: -6000 - 500,\n                },\n                angle: 90,\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W,\n                    y: -6000,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 600,\n                    y: -6000 - 500,\n                },\n                angle: -90,\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: false,\n            },\n        ],\n    },\n    {\n        name: 'The Small High Pot......',\n        ejectAreas: [\n            {\n                x: 200 - 2000,\n                y: 200,\n                w: 1500 / 2,\n                h: 1500 / 2,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W - 600,\n                    y: -6000 - 500,\n                },\n                angle: 90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W,\n                    y: -6000,\n                },\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 600,\n                    y: -6000 - 500,\n                },\n                angle: -90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n        ],\n    },\n    {\n        name: 'The High HIGH throw Pot......',\n        ejectAreas: [\n            {\n                x: 200 - 2500,\n                y: 200 - 3500,\n                w: 2000,\n                h: 2000,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W - 600,\n                    y: -6000 - 500,\n                },\n                angle: 90,\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W,\n                    y: -6000,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 600,\n                    y: -6000 - 500,\n                },\n                angle: -90,\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: false,\n            },\n        ],\n    },\n    {\n        name: 'The Smaaaall Tiny Tilted High Pot......',\n        ejectAreas: [\n            {\n                x: 200 - 1500,\n                y: 200,\n                w: 1500 / 3,\n                h: 1500 / 3,\n            },\n            {\n                x: 200 - 3000 + 400,\n                y: 200,\n                w: 1500 / 3,\n                h: 1500 / 3,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W - 600,\n                    y: -6000 - 500,\n                },\n                angle: 90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 300,\n                    y: -6000 - 200,\n                },\n                angle: -30,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 600,\n                    y: -6000 - 500,\n                },\n                angle: -90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n        ],\n    },\n    {\n        name: 'The Precision Small High Pot..',\n        ejectAreas: [\n            {\n                x: -1900,\n                y: -2400,\n                w: 1500 / 3,\n                h: 1500 / 3,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W - 200,\n                    y: -6000 - 500,\n                },\n                angle: 90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W,\n                    y: -6000 - 200,\n                },\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 200,\n                    y: -6000 - 500,\n                },\n                angle: -90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n        ],\n    },\n    {\n        name: 'The Ultra Precision Small High Pot.. !',\n        ejectAreas: [\n            {\n                x: -1900,\n                y: -2400,\n                w: 1500 / 5,\n                h: 1500 / 5,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W - 200,\n                    y: -6000 - 500,\n                },\n                angle: 90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W,\n                    y: -6000 - 200,\n                },\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 200,\n                    y: -6000 - 500,\n                },\n                angle: -90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n        ],\n    },\n    {\n        name: 'The Ultra Precision Small High Pot With a Tiny Eject Area.. !',\n        ejectAreas: [\n            {\n                x: -1900,\n                y: -2400,\n                w: 50,\n                h: 50,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W - 200,\n                    y: -6000 - 500,\n                },\n                angle: 90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W,\n                    y: -6000 - 200,\n                },\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: true,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W + 200,\n                    y: -6000 - 500,\n                },\n                angle: -90,\n                texture: textures_TEXTURES_MAP.GROUND2,\n                withFlag: false,\n            },\n        ],\n    },\n    // 12\n    {\n        name: 'The Great Throw !',\n        ejectAreas: [\n            {\n                x: 200 - 4000,\n                y: 200,\n                w: 1500 / 1.5,\n                h: 1500 / 1.5,\n            },\n        ],\n        ground: [\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 4 + 550,\n                    y: -1000,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: false,\n            },\n            {\n                pos: {\n                    // relativeToWater: true,\n                    x: GROUND_W * 5 + 550,\n                    y: -1000,\n                },\n                texture: textures_TEXTURES_MAP.GROUND1,\n                withFlag: true,\n            },\n        ],\n    },\n    // 13\n    {\n        name: 'Editor Level',\n        isFromEditor: true,\n        ground: [\n            {\n                x: -1941,\n                y: 1084,\n                angle: -17,\n                texture: 'GROUND2',\n                withFlag: false,\n                pos: {\n                    x: -1941,\n                    y: 1084,\n                },\n            },\n            {\n                x: -1610,\n                y: 1035,\n                angle: 0,\n                texture: 'GROUND2',\n                withFlag: true,\n                pos: {\n                    x: -1610,\n                    y: 1035,\n                },\n            },\n        ],\n        ejectAreas: [\n            {\n                x: -2695,\n                y: 1075,\n                angle: 0,\n                texture: 'GROUND1',\n                withFlag: false,\n                w: 582,\n                h: 396,\n            },\n        ],\n    },\n    // 14\n    // {\n    //   name: 'Editor Level 2',\n    //   isFromEditor: true,\n    //   ground: [\n    //     {\n    //       x: -3484,\n    //       y: 1123,\n    //       angle: 20,\n    //       texture: 'GROUND2',\n    //       withFlag: true,\n    //       w: 800,\n    //       h: 800,\n    //       pos: {\n    //         x: -3484,\n    //         y: 1123,\n    //       },\n    //     },\n    //     {\n    //       x: -1773,\n    //       y: 1230,\n    //       angle: 0,\n    //       texture: 'GROUND1',\n    //       withFlag: true,\n    //       pos: {\n    //         x: -1773,\n    //         y: 1230,\n    //       },\n    //     },\n    //     {\n    //       x: -2022,\n    //       y: 1212,\n    //       angle: 0,\n    //       texture: 'GROUND2',\n    //       withFlag: true,\n    //       pos: {\n    //         x: -2022,\n    //         y: 1212,\n    //       },\n    //     },\n    //     {\n    //       x: -3193,\n    //       y: 607,\n    //       angle: 0,\n    //       texture: 'GROUND2',\n    //       withFlag: false,\n    //       pos: {\n    //         x: -3193,\n    //         y: 607,\n    //       },\n    //     },\n    //   ],\n    //   ejectAreas: [\n    //     {\n    //       x: -1885,\n    //       y: 1567,\n    //       angle: 0,\n    //       texture: 'GROUND1',\n    //       withFlag: false,\n    //       w: 800,\n    //       h: 800,\n    //     },\n    //     {\n    //       x: -2776,\n    //       y: 631,\n    //       w: 300,\n    //       h: 300,\n    //       angle: 0,\n    //     },\n    //   ],\n    // },\n    // {\n    //   name: 'Editor Level 4',\n    //   isFromEditor: true,\n    //   ground: [\n    //     {\n    //       x: -3570,\n    //       y: 893,\n    //       angle: -47,\n    //       texture: 'GROUND1',\n    //       withFlag: false,\n    //       pos: {\n    //         x: -3570,\n    //         y: 893,\n    //       },\n    //     },\n    //     {\n    //       x: -2374,\n    //       y: 1416,\n    //       angle: 9,\n    //       texture: 'GROUND2',\n    //       withFlag: true,\n    //       pos: {\n    //         x: -2374,\n    //         y: 1416,\n    //       },\n    //     },\n    //     {\n    //       x: -2136,\n    //       y: 1269,\n    //       angle: -85,\n    //       texture: 'GROUND2',\n    //       withFlag: true,\n    //       pos: {\n    //         x: -2136,\n    //         y: 1269,\n    //       },\n    //     },\n    //   ],\n    //   ejectAreas: [\n    //     {\n    //       x: -3021,\n    //       y: 1157,\n    //       w: 636,\n    //       h: 597,\n    //       angle: -24,\n    //     },\n    //   ],\n    // },\n    {\n        name: 'Editor Level 4',\n        isFromEditor: true,\n        ground: [\n            {\n                x: -2398,\n                y: 476,\n                angle: 0,\n                texture: 'GROUND1',\n                withFlag: true,\n                pos: {\n                    x: -2398,\n                    y: 476,\n                },\n            },\n            {\n                x: -2844,\n                y: 1382,\n                angle: 0,\n                texture: 'GROUND1',\n                withFlag: false,\n                pos: {\n                    x: -2844,\n                    y: 1382,\n                },\n            },\n            {\n                x: -3448,\n                y: 1144,\n                angle: 90,\n                texture: 'GROUND2',\n                withFlag: false,\n                pos: {\n                    x: -3448,\n                    y: 1144,\n                },\n            },\n            {\n                x: -2230,\n                y: 1207,\n                angle: -90,\n                texture: 'GROUND2',\n                withFlag: true,\n                pos: {\n                    x: -2230,\n                    y: 1207,\n                },\n            },\n            {\n                x: -3724,\n                y: 529,\n                angle: -180,\n                texture: 'GROUND2',\n                withFlag: false,\n                pos: {\n                    x: -3724,\n                    y: 529,\n                },\n            },\n            {\n                x: -3479,\n                y: 1493,\n                angle: 45,\n                texture: 'GROUND1',\n                withFlag: false,\n                pos: {\n                    x: -3479,\n                    y: 1493,\n                },\n            },\n        ],\n        ejectAreas: [\n            {\n                x: -2863,\n                y: 849,\n                w: 1300,\n                h: 1300,\n                angle: 0,\n            },\n            {\n                x: -3612,\n                y: 822,\n                angle: 0,\n                texture: 'GROUND1',\n                withFlag: false,\n                w: 200,\n                h: 200,\n            },\n        ],\n    },\n];\nconst getLevelCount = () => Levels.length;\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/createBeforeGameLevelSelection.ts\n\n\n\n\n\n\n\n\n\nconst createBeforeGameLevelSelection = () => {\n    const scene = ObservableScenes.foreground;\n    const state = {\n        allElems: [],\n        gameTitleText: null,\n        levelButtons: [],\n        btnStart: null,\n        selectedLvlName: null,\n        selectedLvlInd: 0,\n    };\n    const getSelectedLvlInd = () => state.selectedLvlInd;\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => {\n            // todo? child observers?\n        },\n        [gameEvents.GAME_START]: () => {\n            state.allElems.forEach((b) => b.setVisible(false));\n        },\n        [gameEvents.SCREEN_GO_TO_BEFORE_GAME]: () => {\n            if ((0,es/* isEmpty */.xbD)(state.levelButtons)) {\n                const startLevelEditor = () => {\n                    dispatchEvent('LEVEL_SET_LEVEL', {\n                        payload: { index: LEVEL_EDITOR_INDEX },\n                    });\n                    defer(() => {\n                        dispatchEvent(gameEvents.GAME_START);\n                        defer(() => dispatchEvent(gameEvents.GAME_EDIT));\n                    });\n                };\n                const editorLvlBtn = createLabelBtnText({\n                    text: `Editor`,\n                    scene,\n                    config: {},\n                    coords: { x: 150, y: 150 },\n                })\n                    .setInteractive()\n                    .setFontSize('3.5rem')\n                    .on('pointerdown', () => {\n                    console.log('CLICK EditOR');\n                    startLevelEditor();\n                });\n                state.allElems.push(editorLvlBtn);\n                state.levelButtons = Levels.map((lvlConf, ind) => createLabelBtnText({ text: `${ind + 1}`, scene, config: {} })\n                    .setInteractive()\n                    .setFontSize('3.5rem')\n                // .setData('isSelected', false)\n                );\n                // initial selected state\n                const _updateBtnSelectedState = (b, ind) => {\n                    ind === getSelectedLvlInd()\n                        ? b.setFontSize('3.5rem').setShadow(0, 2, '#000', 5, true)\n                        : b.setFontSize('3.5rem').setShadow(0);\n                };\n                state.levelButtons.forEach((b, _ind) => {\n                    // initial\n                    _updateBtnSelectedState(b, _ind);\n                    b.on('pointerdown', (__b) => {\n                        //   __b.setData('isSelected', true)\n                        // SELECT THIS LEVEL\n                        state.selectedLvlInd = parseInt(b.text) - 1;\n                        dispatchDeferredEvent('LEVEL_SET_LEVEL', {\n                            payload: { index: state.selectedLvlInd },\n                        });\n                        state.selectedLvlName?.setText(`Level: ${Levels[state.selectedLvlInd].name}`);\n                        // select/unselect the other buttons\n                        state.levelButtons.forEach((_b, _ind) => _updateBtnSelectedState(_b, _ind));\n                    });\n                });\n                Phaser.Actions.GridAlign(state.levelButtons, {\n                    width: 500,\n                    height: 300,\n                    cellWidth: 100,\n                    cellHeight: 100,\n                    x: 200,\n                    y: 300,\n                });\n                state.allElems.push(...state.levelButtons);\n                // AUTOSTART THE EDITOR / hardcoded for now:\n                waitMs().then(startLevelEditor);\n            }\n            exposeToWindow({ ...state });\n            ////////// BTN START\n            if (!state.btnStart) {\n                state.btnStart = createLabelBtnText({\n                    scene,\n                    coords: { x: 150, y: 500 },\n                    text: 'GO >>>',\n                    config: { fontSize: '5rem' },\n                });\n                state.btnStart.on('pointerdown', () => {\n                    dispatchEvent(gameEvents.GAME_START);\n                });\n                state.allElems.push(state.btnStart);\n            }\n            /////////// SELECTED LVL NAME DIsPLAYED\n            if (!state.selectedLvlName) {\n                state.selectedLvlName = createLabelBtnText({\n                    scene,\n                    coords: { x: 150, y: 400 },\n                    text: `Level: ${Levels[0].name}`,\n                    config: { fontSize: '5rem' },\n                });\n                state.allElems.push(state.selectedLvlName);\n            }\n            /////////// GAME TITLE TEXT\n            if (!state.gameTitleText) {\n                state.gameTitleText = centerXText(createLabelBtnText({\n                    scene,\n                    coords: { x: 150, y: 50 },\n                    text: `Airborn Island Delivery!`,\n                    config: { fontSize: '4rem' },\n                }));\n                state.allElems.push(state.gameTitleText);\n            }\n            state.allElems.forEach((b) => b.setVisible(true));\n            setTimeout(() => {\n                // FONT SIZE BUG\n                state.allElems.forEach((el) => el.setFontFamily('\"VT323\", Verdana, Arial'));\n                state.selectedLvlName.setFontSize('3.5rem');\n                state.btnStart.setFontSize('4rem');\n                state.gameTitleText.setFontSize('4rem');\n                setTimeout(() => centerXText(state.gameTitleText));\n            }, 50);\n        },\n        [sceneEvents.UPDATE]: () => {\n            // if (_state.keySpace && scene.input.keyboard.checkDown(_state.keySpace, 500)) {\n            //   _state.isPaused = !_state.isPaused\n            //   _state.isPaused ? GameFlow.pauseGame() : GameFlow.resumeGame()\n            //   debugLog('PAUSED')\n            // }\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            // GlobalObservers.removeMultipleObs(observers)\n            // _state.keySpace?.destroy()\n            // _state.keySpace = null\n        },\n    });\n};\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/createPause.ts\n\n\n\n\n\n\n\n\n\nconst createPause_dispatchGamePause = common_throttle(100, () => dispatchEvent(gameEvents.GAME_PAUSE));\nconst createPause_dispatchGameResume = common_throttle(100, () => dispatchEvent(gameEvents.GAME_RESUME));\nconst createPause = () => {\n    const state = {\n        keyPause: false,\n        wasd: [false, false, false, false],\n        canChangePausedState: true,\n        isPaused: false,\n    };\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => {\n            //\n        },\n        [inputEvents.INPUT_UPDATE_STATE]: (ev) => {\n            const keys = payloadProp('keys')(ev);\n            state.keyPause = keys.p;\n            state.wasd = [keys.w, keys.a, keys.s, keys.d];\n        },\n        [sceneEvents.UPDATE]: () => {\n            if (!isInGame())\n                return;\n            if (state.keyPause && isInGame()) {\n                if (!state.canChangePausedState)\n                    return;\n                ///\n                state.canChangePausedState = false;\n                setTimeout(() => (state.canChangePausedState = true), 300);\n                ///\n                state.isPaused ? createPause_dispatchGameResume() : createPause_dispatchGamePause();\n            }\n        },\n        [gameEvents.GAME_PAUSE]: () => {\n            if (state.isPaused)\n                return;\n            state.isPaused = true;\n            // handle general pausing logic\n            ObservableScenes.game.matter.world.pause();\n            camera_mainCam(ObservableScenes.game).stopFollow();\n            // TODO: also shold pause any tweens\n            // ObservableScenes.game.scene.pause()\n        },\n        [gameEvents.GAME_RESUME]: () => {\n            if (!state.isPaused)\n                return;\n            state.isPaused = false;\n            // handle general un-pausing logic\n            ObservableScenes.game.matter.world.resume();\n            // ObservableScenes.game.scene.resume()\n        },\n        [obsDispEvents.OBS_REMOVE]: () => { },\n    });\n};\n// TODO: allow resume/pause a game via events\n//// serviceSpawnBirdWave.pause()\n/*\nSIMPLEST / still plays animations! - cool :::\n\n\nObservableScenes.game.tweens.pauseAll()\nObservableScenes.game.matter.world.enabled = false\n\n\nObservableScenes.game.tweens.resumeAll()\nObservableScenes.game.matter.world.enabled = true\n\n\n\nOLD::\nserviceSpawnBirdWave.pause()\nsceneBackground.scene.pause()\nsc.scene.pause()\n\n\n\nserviceSpawnBirdWave.resume()\nsceneBackground.scene.resume()\nsc.scene.resume()\n\n*/\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/createRestart.ts\n\n\n\n\n\n\nconst createRestart = () => {\n    const state = {\n        keyRestart: false,\n        canRestartAgain: true,\n    };\n    const restart = () => {\n        if (!state.canRestartAgain)\n            return;\n        ///\n        state.canRestartAgain = false;\n        setTimeout(() => (state.canRestartAgain = true), 300);\n        ///\n        // MANUAL\n        dispatchEvent(gameEvents.GAME_RESTART);\n        dispatchDeferredEvent(gameEvents.GAME_START);\n    };\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => {\n            //\n        },\n        [inputEvents.INPUT_UPDATE_STATE]: (ev) => {\n            const keys = payloadProp('keys')(ev);\n            state.keyRestart = keys.r;\n        },\n        [gameEvents.GAME_REQUEST_RESTART]: restart,\n        [sceneEvents.UPDATE]: () => {\n            if (state.keyRestart && isInGame()) {\n                if (!state.canRestartAgain)\n                    return;\n                restart();\n            }\n        },\n        [obsDispEvents.OBS_REMOVE]: () => { },\n    });\n};\n\n;// CONCATENATED MODULE: ./src/game/airbornDelivery/createToasts.ts\n\n\n\nconst createToasts = (config) => {\n    const state = {\n        text: null,\n        currentTween: null,\n    };\n    return addObsDisp({\n        [obsDispEvents.OBS_CREATE]: ({ payload: {} }) => { },\n        ['TOAST_CREATE']: (ev) => {\n            state.text =\n                state.text ||\n                    centerText(createLabelBtnText({\n                        scene: ObservableScenes.foreground,\n                        coords: { x: -1, y: -1 },\n                        text: '',\n                    }));\n            const text = payloadProp('text')(ev);\n            centerText(state.text.setText(text));\n            // console.log('CREATE TOAST: ', text)\n            state.currentTween?.remove();\n            state.currentTween = ObservableScenes.foreground.add.tween({\n                targets: [state.text],\n                scale: { from: 1, to: 1.3 },\n                duration: 2000,\n                yoyo: true,\n                repeat: 0,\n                onComplete: () => {\n                    state.text?.destroy();\n                    state.text = null;\n                },\n            });\n        },\n        [obsDispEvents.OBS_REMOVE]: () => {\n            // GlobalObservers.removeMultipleObs(observers)\n            // _state.keySpace?.destroy()\n            // _state.keySpace = null\n        },\n    });\n};\n\n;// CONCATENATED MODULE: ./src/scenes/ForegroundScene.ts\n\n\n\n\n\n\n\n/** Use for UI / things that don't scroll with the game */\nconst ForegroundScene = createObservableScene({\n    key: 'FOREGROUND_SCENE',\n    createObservers: (scene) => [\n        // initControlsObserver(scene),\n        createBeforeGameLevelSelection(),\n        // TODO:LD - for when the game is played ?\n        // createUIStartMenu(),\n        createPause(),\n        createRestart(),\n        createToasts(),\n        createInGameUI(),\n    ],\n    onCreate: (scene) => {\n        sendSceneToTop(scene);\n    },\n});\n/* harmony default export */ const scenes_ForegroundScene = (ForegroundScene);\n\n;// CONCATENATED MODULE: ./src/boot.ts\n/// <reference types= \"../node_modules/phaser/types\" />\n// import Phaser from 'phaser'\n// Phaser /* needed */\n\n\n\n\n\n\nclass boot_Game extends Phaser.Game {\n    constructor(config) {\n        super(config);\n    }\n}\nconst IS_PHONE = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|IEMobile|IS_MOCKED_PHONE)/);\n// note: this can be added to the Chrome Mobile DevTools userAgent (to virtual devices)\nconst IS_MOCKED_PHONE = navigator.userAgent.match(/(IS_MOCKED_PHONE)/);\nconst onDeviceReady = async () => {\n    const configureDisplayCutout = window.DisplayCutout\n        ? () => new Promise((resolve, reject) => {\n            window.DisplayCutout.setDisplayCutout(window.DisplayCutout.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES, resolve, reject);\n        })\n        : () => Promise.resolve();\n    await configureDisplayCutout().catch((err) => debug_debugWarn('DisplayCutout error: ', err));\n    // Mobile: NOTE: for some reason we NEED to also retrieve! the displayCutout size,\n    // otherwise it will not affect correctly??\n    // await updateGlobalDisplayCutoutAfterSet()\n    window?.screen?.orientation?.lock('landscape').catch(noop);\n    // const scaleFactor = !IS_PHONE_OR_ELECTRON && !IS_MOCKED_PHONE ? 16 / 9 : getScreenRatio()\n    const canvas = getGameCanvas();\n    canvas.onscroll = (ev) => ev.preventDefault(); // FIX THE SLIGHT-SCROLLING OF CANVAS BUG (we need the canvas be fullscreen)\n    // const refreshRate = await getDeviceRefreshRate()\n    // setGlobalVar('__FPS', refreshRate)\n    // debugLog('FPS TO USE (refresh rate)', refreshRate)\n    const config = {\n        title: '~~ ~~',\n        type: Phaser.WEBGL,\n        backgroundColor: '#ffffff', // Could be black too\n        pixelArt: false,\n        transparent: false,\n        width: screen_getScreenDprWidth(),\n        height: screen_getScreenDprHeight(),\n        // width: Math.min(1920 / DPR, getScreenDprWidth()),\n        // height: Math.min(1080 / DPR, getScreenDprHeight()),\n        render: {},\n        scale: { mode: Phaser.Scale.ScaleModes.FIT },\n        scene: [BootScene, scenes_BackgroundScene, scenes_ForegroundScene],\n        canvas,\n        dom: {\n            createContainer: true,\n        },\n        physics: {\n            default: 'matter',\n            matter: {\n                debug: false,\n                // debug: {\n                //   showBounds: true,\n                //   showCollisions: true,\n                //   showBody: true,\n                //   // NOTE:CONFIG - the 'oreol' no matter what the alpha is!\n                //   lineColor: 'blue',\n                //   showPositions: false,\n                //   // positionColor\n                // },\n                gravity: { y: 0, x: 0 }, // scale: 0.0001 },\n                autoUpdate: true,\n                /// HIGHER-MOITOR-REFRESH-RATE-ISSUES:SOLVED - keep the 3 variables unset (keep default: 2) - higher\n                /// could make the simulation different on higher refresh rate\n                // NO: positionIterations: 10,\n                // NO: velocityIterations: 10,\n                // NO: constraintIterations: 10,\n                runner: {\n                    // HIGHER-MOITOR-REFRESH-RATE-ISSUES:SOLVED: have autoUpdate: false, fps: 60 (but can be lower) and .step:\n                    isFixed: true,\n                    fps: 60, // 60, // MUST BE LOCKED to work properly;\n                },\n            },\n        },\n        // pipeline: { HueRotatePostFX },\n        plugins: {\n            scene: [\n            // {\n            //   key: 'rexGestures',\n            //   plugin: GesturesPlugin,\n            //   mapping: 'rexGestures',\n            // },\n            // {\n            //   key: 'rexUI',\n            //   plugin: RexUIPlugin,\n            //   mapping: 'rexUI',\n            // },\n            // {\n            //   key: 'rexModal',\n            //   plugin: RexModalPlugin,\n            //   mapping: 'rexModal',\n            // },\n            ],\n        },\n    };\n    const game = new boot_Game(config);\n    // TODO:ALE:000 - check env editor (from webpack).. see how to do it;\n    // waitMs(1000).then(() => {\n    //   initializeEditor(game)\n    // })\n};\n// when a browser game! ::\n// onDeviceReady() // NOTE: this is for testing in Chrome when we do server the project\n// document.documentElement.requestFullscreen()\nif (IS_MOCKED_PHONE) {\n    onDeviceReady();\n}\nif (IS_PHONE) {\n    const waitForDeviceReady = () => {\n        return new Promise((resolve) => document.addEventListener('deviceready', resolve, false));\n    };\n    Promise.all([\n        /* waitForElectronReadyEvent(), */\n        waitForDeviceReady(),\n    ]).then(onDeviceReady);\n}\nelse {\n    // ELECTRON / web\n    onDeviceReady();\n}\n\n\n//# sourceURL=webpack://ld-55/./src/boot.ts_+_90_modules?")}},__webpack_module_cache__={},deferred;function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.m=__webpack_modules__,deferred=[],__webpack_require__.O=(e,n,t,s)=>{if(!n){var a=1/0;for(c=0;c<deferred.length;c++){for(var[n,t,s]=deferred[c],o=!0,r=0;r<n.length;r++)(!1&s||a>=s)&&Object.keys(__webpack_require__.O).every((e=>__webpack_require__.O[e](n[r])))?n.splice(r--,1):(o=!1,s<a&&(a=s));if(o){deferred.splice(c--,1);var i=t();void 0!==i&&(e=i)}}return e}s=s||0;for(var c=deferred.length;c>0&&deferred[c-1][2]>s;c--)deferred[c]=deferred[c-1];deferred[c]=[n,t,s]},__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),(()=>{var e;__webpack_require__.g.importScripts&&(e=__webpack_require__.g.location+"");var n=__webpack_require__.g.document;if(!e&&n&&(n.currentScript&&(e=n.currentScript.src),!e)){var t=n.getElementsByTagName("script");if(t.length)for(var s=t.length-1;s>-1&&!e;)e=t[s--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=e})(),(()=>{var e={179:0};__webpack_require__.O.j=n=>0===e[n];var n=(n,t)=>{var s,a,[o,r,i]=t,c=0;if(o.some((n=>0!==e[n]))){for(s in r)__webpack_require__.o(r,s)&&(__webpack_require__.m[s]=r[s]);if(i)var l=i(__webpack_require__)}for(n&&n(t);c<o.length;c++)a=o[c],__webpack_require__.o(e,a)&&e[a]&&e[a][0](),e[a]=0;return __webpack_require__.O(l)},t=self.webpackChunkld_55=self.webpackChunkld_55||[];t.forEach(n.bind(null,0)),t.push=n.bind(null,t.push.bind(t))})();var __webpack_exports__=__webpack_require__.O(void 0,[216],(()=>__webpack_require__(585)));__webpack_exports__=__webpack_require__.O(__webpack_exports__)})();